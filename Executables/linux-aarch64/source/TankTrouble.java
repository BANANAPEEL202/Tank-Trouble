/* autogenerated by Processing revision 1286 on 2023-06-08 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import garciadelcastillo.dashedlines.*;
import java.util.*;
import java.util.ArrayList;
import java.util.*;
import java.util.ArrayList;
import java.util.*;
import java.util.ArrayList;
import ddf.minim.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class TankTrouble extends PApplet {



public Queue<Cell> q = new LinkedList<Cell>();
final static float MOVE_SPEED = 3;
final static float ANGLESPEED = 4.2f;
final static boolean DEBUG = false;
final static float POWERSIZE = 25/2;

int POWERCOUNT = 0;
float OFFSETY = 0;
float OFFSETX = 0;
Minim minim;
boolean BLUE = false;
boolean ORANGE = false;

int startGameDelay = 15;

int WIDTH = 1200; //WIDTH OF THE WINDOW'S SCREEN
int HEIGHT = 750; //HEIGHT OF THE WINDOW'S SCREEN

int CELL_SIZE = 80;
Tank redTank;
Tank greenTank;
Tank blueTank;
Tank orangeTank;
Maze maze;
static ArrayList<Tank> tankList = new ArrayList<Tank>();
ArrayList<Explosion> explosions = new ArrayList<Explosion>();
int gameOverTimer = 3*60;
int blueTimer= -1;
boolean blueBrake = false;
DashedLines dash;

boolean skipScreen = false;

boolean INGAME = false;
boolean STARTMENU = true;
boolean CONTROLS = false;
boolean STATS = false;
boolean greenReady = false;
boolean redReady = false;
boolean blueReady = true;
boolean orangeReady = true;
PImage background;
PImage FourPlayerBtn;
PImage TwoPlayerBtn;
PImage ThreePlayerBtn;

PImage greenIcon;
PImage redIcon;
PImage blueIcon;
PImage orangeIcon;

PImage controlBg;
PImage redControl1;
PImage redControl2;
PImage redControl3;
PImage greenControl1;
PImage greenControl2;
PImage greenControl3;
PImage orangeControl1;
PImage orangeControl2;
PImage orangeControl3;
PImage blueControl1;
PImage blueControl2;
PImage blueControl3;

PImage greenStats;
PImage redStats;
PImage blueStats;
PImage orangeStats;

PImage statsTemplate;
PImage statsButton;
float statsAngle = 0;
//Missle testMissle;

PFont bold, regular, light;
boolean focused2 = true;
int totalGames = 0;
int startTime;

AudioPlayer clickSound;


 public void setup()
{
  /* size commented out by preprocessor */;
  bold = createFont("Stats/Akzidenz-grotesk-bold.ttf", 24);
  regular = createFont("Stats/Akzidenz-grotesk-roman.ttf", 24);
  light = createFont("Stats/Akzidenz-grotesk-light.ttf", 24);

  surface.setTitle("Tank Trouble  v1.1.0");
  surface.setResizable(true);
  imageMode(CENTER);
  dash = new DashedLines(this);
  // Set the dash-gap pattern in pixels
  dash.pattern(8, 10);
  minim = new Minim(this);

  greenIcon = loadImage("Green Tank Icon.png");
  redIcon=loadImage("Red Tank Icon.png");
  blueIcon=loadImage("Blue Tank Icon.png");
  orangeIcon = loadImage("Orange Tank Icon.png");
  background = loadImage("Tank Trouble Background.png");
  FourPlayerBtn = loadImage("4 Player.png");
  TwoPlayerBtn = loadImage("2 Player.png");
  ThreePlayerBtn = loadImage("3 Player.png");

  controlBg = loadImage("Controls/Controls Background.png");
  redControl1  = loadImage("Controls/Red Control 1.png");
  redControl2  = loadImage("Controls/Red Control 2.png");
  greenControl1  = loadImage("Controls/Green Control 1.png");
  greenControl2  = loadImage("Controls/Green Control 2.png");
  orangeControl1 = loadImage("Controls/Orange Control 1.png");
  orangeControl2 = loadImage("Controls/Orange Control 2.png");
  blueControl1 = loadImage("Controls/Blue Control 1.png");
  blueControl2 = loadImage("Controls/Blue Control 2.png");

  redControl3  = loadImage("Controls/Red Control 3.png");
  greenControl3  = loadImage("Controls/Green Control 3.png");
  orangeControl3 = loadImage("Controls/Orange Control 3.png");
  blueControl3 = loadImage("Controls/Blue Control 3.png");

  greenStats = loadImage("Stats/Green Stats.png");
  redStats = loadImage("Stats/Red Stats.png");
  orangeStats = loadImage("Stats/Orange Stats.png");
  blueStats = loadImage("Stats/Blue Stats.png");
  statsTemplate = loadImage("Stats/Stats Template.png");
  statsButton = loadImage("Stats/Stats Button.png");

  //testMissle = new Missle(25,25, 0, maze);
  drawStartMenu();
  if (skipScreen)
  {
    INGAME = true;
    STARTMENU = false;
    //STATS=true;
    BLUE = true;
    ORANGE = true;
    startGame();
  }
  clickSound = minim.loadFile("Sounds/Click.mp3");
}

 public void windowResized()
{
  int newHeight = height;
  int newWidth = round(height/900.0f*1200);

  windowResize(newWidth, newHeight) ;
  //windowRatio(newWidth, newHeight);  
}


 public void drawGame()
{
  background(255);
   OFFSETX = (1200-WIDTH)/2;
      OFFSETY = (750-HEIGHT)/2;
 for (Explosion explosion : explosions)
      {
        explosion.display();
        OFFSETY += explosion.generateOffset();
        OFFSETX += explosion.generateOffset();
      }
      if (BLUE)
      {
        blueMovement();
      }
      displayPowerUps();
      for (Tank tank : tankList)
      {
        if (tank.beam != null)
        {
          updateBeam(tank.beam);
          beamCollision(tank.beam);
        }
        tank.display();
        if (tank.missle != null)
        {
          getTargetTank(tank.missle);
        }
      }




      bulletWallCollision();
      tankWallCollision();
      tankBulletCollision();
      bulletCornerCollision();
      missleWallCollision();
      barrelWallCollision();

      if (POWERCOUNT <= 15)
      {
        maze.generatePowerUps();
      }
      tankPowerUpCollision();

     
      if (DEBUG)
      {
        maze.viewCorners();
      }
      checkGameOver();
      displayMaze();
      drawScore();
      drawStatsButton();
}

 public void draw()
{
    pushMatrix();
  scale(height/900.0f);

     if (focused)
     {
         background(255);
     }
  
    if (INGAME)
    {
        if (focused)
  {
     drawGame();
  }
  else
  {
    if (focused2)
    {
    fill(color(255,155));
    rect(-10,-10,1220,920);
    fill(0xFF414141);
    rect(600-40, 450-50, 30, 100);
     rect(600+10, 450-50, 30, 100);

    }
    focused2 = false;
  }
  
    } else if (STARTMENU)
    {
      drawStartMenu();
    } else if (CONTROLS)
    {
      image(controlBg, 1200/2, 900/2, 1200, 900);
      int tanks = 2;
      if (BLUE)
      {
        tanks=3;
      }
      if (ORANGE)
      {
        tanks=4;
      }

      float inBetween = 1500.0f/(tanks+1);
      int interval = 30;
      for (int i = 0; i < tanks; i++)
      {
        float x = (i+1)*inBetween-150; //-(1500-1200)/2
        if (i==0)
        {
          if (!greenReady)
          {
            if ((frameCount/interval)%2==0)
            {
              image(greenControl1, x, 450);
            } else
            {
              image(greenControl2, x, 450);
            }
          } else
          {
            image(greenControl3, x, 450);
          }
        }
        if (i==1)
        {
          if (!redReady)
          {
            if ((frameCount/interval)%2==0)
            {
              image(redControl1, x, 450);
            } else
            {
              image(redControl2, x, 450);
            }
          } else
          {
            image(redControl3, x, 450);
          }
        }
        if (BLUE && i == 2)
        {
          if (!blueReady)
          {
            if ((frameCount/interval)%2==0)
            {
              image(blueControl1, x, 450);
            } else
            {
              image(blueControl2, x, 450);
            }
          } else
          {
            image(blueControl3, x, 450);
          }
        }
        if (ORANGE && i == 3)
        {
          if (!orangeReady)
          {
            if ((frameCount/interval)%2==0)
            {
              image(orangeControl1, x, 450);
            } else
            {
              image(orangeControl2, x, 450);
            }
          } else
          {
            image(orangeControl3, x, 450);
          }
        }
      }
      if (redReady && greenReady && blueReady && orangeReady)
      {
        startGameDelay--;
        if (startGameDelay < 0)
        {
          startGame();
          INGAME = true;
          CONTROLS = false;
        }
      }
    } else if (STATS)
    {
      
      drawStats();
    }
popMatrix();
if (clickSound != null && !clickSound.isPlaying() && clickSound.position() != 0)
    {
      clickSound.rewind();
    }
    //println("X: " + mouseX + "  Y: " + mouseY);
  }



public void drawStartMenu()
{
  int scaledMouseX = mouseX*1200/width;
  int scaledMouseY = mouseY*900/height;
  image(background, 1200/2, 900/2, 1200, 900);
  if (108 < scaledMouseX && scaledMouseX < 394 && 665 < scaledMouseY && scaledMouseY < 747) {
    image(TwoPlayerBtn, 251, 734, TwoPlayerBtn.width*1.1f, TwoPlayerBtn.height*1.1f);
  } else
  {
    image(TwoPlayerBtn, 251, 734, TwoPlayerBtn.width, TwoPlayerBtn.height);
  }
  if (465 < scaledMouseX && scaledMouseX < 742 && 675 < scaledMouseY && scaledMouseY < 756) {
    image(ThreePlayerBtn, 599, 739, ThreePlayerBtn.width*1.1f, ThreePlayerBtn.height*1.1f);
  } else
  {
    image(ThreePlayerBtn, 599, 739, ThreePlayerBtn.width, ThreePlayerBtn.height);
  }
  if (808 < scaledMouseX && scaledMouseX < 1094 && 662 < scaledMouseY && scaledMouseY < 753) {
    image(FourPlayerBtn, 950, 739, FourPlayerBtn.width*1.1f, FourPlayerBtn.height*1.1f);
  } else
  {
    image(FourPlayerBtn, 950, 739, FourPlayerBtn.width, FourPlayerBtn.height);
  }
  fill(0xFF000000);
  textSize(18);


  //text("FPS: " + String.format("%.01f", frameRate), 1110, 880);
}

public void blueMovement()
{
   int scaledMouseX = mouseX*1200/width;
  int scaledMouseY = mouseY*900/height;
  int mouseAngle = (int)(atan2(blueTank.centerY+OFFSETY - scaledMouseY, blueTank.centerX+OFFSETX - scaledMouseX)* 180/ PI);
  if (mouseAngle < 0)
  {
    mouseAngle += 360;
  }
  mouseAngle += 180;
  mouseAngle = mouseAngle%360;
  int tankAngle = (int)blueTank.angle%360;
  if (tankAngle < 0)
  {
    tankAngle += 360;
  }
  tankAngle = tankAngle %360;

  float a = (mouseAngle - tankAngle);
  float b = (mouseAngle - tankAngle + 360);
  float c = (mouseAngle - tankAngle-360);
  float d;
  if (abs(a) < abs(b) && abs(a) < abs(c))
  {
    d = a;
  } else if (abs(b) < abs(a) && abs(b) < abs(c))
  {
    d=b;
  } else
  {
    d=c;
  }
  if (DEBUG)
  {
    println(mouseAngle);
    println(tankAngle);
    println("---");
  }
  if (abs(mouseAngle - tankAngle) < 3)
  {
    blueTank.angleChange = 0;
    float distance = dist(scaledMouseX, scaledMouseY, blueTank.centerX+OFFSETX, blueTank.centerY+OFFSETY);
    if (distance > 40 && !blueBrake)
    {
      blueTank.speed = MOVE_SPEED;
    } else
    {
      blueTank.speed = 0;
    }
  } else if (d < 0)
  {
    blueTank.angleChange = -ANGLESPEED;
  } else
  {
    blueTank.angleChange = ANGLESPEED;
  }
}

public void mousePressed()
{
  if (INGAME)
  {
    if (focused2)
    {
      int scaledMouseX = mouseX*1200/width;
  int scaledMouseY = mouseY*900/height;
      if (20 < scaledMouseX && scaledMouseX < 60 && 840 < scaledMouseY && scaledMouseY < 880) {
      STATS = true;
    }
      else if (BLUE && mouseButton == LEFT)
      {
        blueTank.fire();
      }
      else if (BLUE && mouseButton == RIGHT)
      {
        blueBrake = !blueBrake;
      }
    } else
    {
      focused2 = true;
    }
    
  } else if (STARTMENU)
  {
    int scaledMouseX = mouseX*1200/width;
  int scaledMouseY = mouseY*900/height;
    if (108 < scaledMouseX && scaledMouseX < 394 && 665 < scaledMouseY && scaledMouseY < 747) {
      CONTROLS = true;
      STARTMENU = false;
    }
    if (465 < scaledMouseX && scaledMouseX < 742 && 675 < scaledMouseY && scaledMouseY < 756) {
      BLUE = true;
      blueReady = false;
      CONTROLS = true;
      STARTMENU = false;
    }
    if (808 < scaledMouseX && scaledMouseX < 1094 && 662 < scaledMouseY && scaledMouseY < 753) {
      BLUE = true;
      ORANGE = true;
      blueReady = false;
      orangeReady = false;
      CONTROLS = true;
      STARTMENU = false;
    }
    clickSound.play();
  } else if (CONTROLS)
  {
    if (!blueReady && BLUE)
    {
       minim.loadFile("Sounds/Click.mp3").play();
       blueReady = true;
    }
    
  }
}



public void drawScore()
{
  float inBetween = 1200.0f/(tankList.size()+1);
  for (int i = 0; i < tankList.size(); i++)
  {
    Tank tank = tankList.get(i);

    float x = (i+1)*inBetween+50;
    if (tank.team.equals("Green"))
    {
      image(greenIcon, x-80, 825);
    } else if (tank.team.equals("Red"))
    {
      image(redIcon, x-80, 825);
    } else if (tank.team.equals("Blue"))
    {
      image(blueIcon, x-80, 825);
    } else if (tank.team.equals("Orange"))
    {
      image(orangeIcon, x-80, 825);
    }
    textSize(50);
    fill(0xFF000000);
    text(tank.score/121, x, 840);
  }
  fill(0xFF000000);
  textSize(18);
  text("FPS: " + String.format("%.01f", frameRate), 1110, 880);
}

public void startGame()
{
  totalGames++;
  startTime = millis();
  WIDTH = (int)random(6, 16)*CELL_SIZE;
  HEIGHT = (int)random(6, 10)*CELL_SIZE;
  OFFSETX = (1200-WIDTH)/2;
  OFFSETY = (750-HEIGHT)/2;
  createMaze();
  tankList.clear();
  int redX, redY, blueX, blueY, greenX, greenY, orangeX, orangeY;
  redX = (int)random(0, WIDTH/CELL_SIZE)*CELL_SIZE+CELL_SIZE/2;
  redY = (int)random(0, HEIGHT/CELL_SIZE)*CELL_SIZE+CELL_SIZE/2;
  int angle = (int)random(1, 5)*90;
  redTank = new Tank("Red Tank.png", redX, redY, angle, 0, "Red", maze);
  do
  {
    greenX = (int)random(0, WIDTH/CELL_SIZE)*CELL_SIZE+CELL_SIZE/2;
    greenY = (int)random(0, HEIGHT/CELL_SIZE)*CELL_SIZE+CELL_SIZE/2;
  }
  while (redX==greenX && redY == greenY);
  angle = (int)random(1, 5)*90;
  greenTank = new Tank("Green Tank.png", greenX, greenY, angle, 0, "Green", maze);

  tankList.add(greenTank);
  tankList.add(redTank);
  blueX=0;
  blueY=0;
  if (BLUE)
  {
    blueX = (int)random(0, WIDTH/CELL_SIZE)*CELL_SIZE+CELL_SIZE/2;
    blueY = (int)random(0, HEIGHT/CELL_SIZE)*CELL_SIZE+CELL_SIZE/2;
    do
    {
      blueX = (int)random(0, WIDTH/CELL_SIZE)*CELL_SIZE+CELL_SIZE/2;
      blueY = (int)random(0, HEIGHT/CELL_SIZE)*CELL_SIZE+CELL_SIZE/2;
    }
    while ((blueX==greenX && blueY == greenY) || (blueX==redX && blueY == redY));
    angle = (int)random(1, 5)*90;
    blueTank = new Tank("Blue Tank.png", blueX, blueY, angle, 0, "Blue", maze);
    tankList.add(blueTank);
  }
  if (ORANGE)
  {
    orangeX = (int)random(0, WIDTH/CELL_SIZE)*CELL_SIZE+CELL_SIZE/2;
    orangeY = (int)random(0, HEIGHT/CELL_SIZE)*CELL_SIZE+CELL_SIZE/2;
    do
    {
      orangeX = (int)random(0, WIDTH/CELL_SIZE)*CELL_SIZE+CELL_SIZE/2;
      orangeY = (int)random(0, HEIGHT/CELL_SIZE)*CELL_SIZE+CELL_SIZE/2;
    }
    while ((orangeX==greenX && orangeY == greenY) || (orangeX==redX && orangeY == redY) || (orangeX == blueX && orangeY == blueY));
    angle = (int)random(1, 5)*90;
    orangeTank = new Tank("Orange Tank.png", orangeX, orangeY, angle, 0, "Orange", maze);
    tankList.add(orangeTank);
    Collections.swap(tankList, 1, 3);
    Collections.swap(tankList, 2, 3);
  }
  gameOverTimer = 2*60;
}

public void startNewGame()
{
  totalGames++;
  minim.stop();
  minim = new Minim(this);
  WIDTH =(int)random(6, 16)*CELL_SIZE;
  HEIGHT = (int)random(6, 10)*CELL_SIZE;
  OFFSETX = (1200-WIDTH)/2;
  OFFSETY = (750-HEIGHT)/2;
  createMaze();
  POWERCOUNT=0;
  tankList.clear();
  int redX, redY, blueX, blueY, greenX, greenY, orangeX, orangeY;
  redX = (int)random(0, WIDTH/CELL_SIZE)*CELL_SIZE+CELL_SIZE/2;
  redY = (int)random(0, HEIGHT/CELL_SIZE)*CELL_SIZE+CELL_SIZE/2;
  int angle = (int)random(1, 5)*90;
  redTank.reset(redX, redY, angle, maze);
  do
  {
    greenX = (int)random(0, WIDTH/CELL_SIZE)*CELL_SIZE+CELL_SIZE/2;
    greenY = (int)random(0, HEIGHT/CELL_SIZE)*CELL_SIZE+CELL_SIZE/2;
  }
  while (redX==greenX && redY == greenY);
  angle = (int)random(1, 5)*90;
  greenTank.reset(greenX, greenY, angle, maze);

  tankList.add(greenTank);
  tankList.add(redTank);

  if (BLUE)
  {
    blueX = (int)random(0, WIDTH/CELL_SIZE)*CELL_SIZE+CELL_SIZE/2;
    blueY = (int)random(0, HEIGHT/CELL_SIZE)*CELL_SIZE+CELL_SIZE/2;
    do
    {
      blueX = (int)random(0, WIDTH/CELL_SIZE)*CELL_SIZE+CELL_SIZE/2;
      blueY = (int)random(0, HEIGHT/CELL_SIZE)*CELL_SIZE+CELL_SIZE/2;
    }
    while ((blueX==greenX && blueY == greenY) || (blueX==redX && blueY == redY));
    angle = (int)random(1, 5)*90;
    blueTank.reset(blueX, blueY, angle, maze);
    tankList.add(blueTank);
  }
  blueX=0;
  blueY=0;
  if (ORANGE)
  {
    orangeX = (int)random(0, WIDTH/CELL_SIZE)*CELL_SIZE+CELL_SIZE/2;
    orangeY = (int)random(0, HEIGHT/CELL_SIZE)*CELL_SIZE+CELL_SIZE/2;
    do
    {
      orangeX = (int)random(0, WIDTH/CELL_SIZE)*CELL_SIZE+CELL_SIZE/2;
      orangeY = (int)random(0, HEIGHT/CELL_SIZE)*CELL_SIZE+CELL_SIZE/2;
    }
    while ((orangeX==greenX && orangeY == greenY) || (orangeX==redX && orangeY == redY) || (orangeX == blueX && orangeY == blueY));
    angle = (int)random(1, 5)*90;
    orangeTank.reset(orangeX, orangeY, angle, maze);
    tankList.add(orangeTank);
    Collections.swap(tankList, 1, 3);
    Collections.swap(tankList, 2, 3);
  }
  gameOverTimer = 2*60;
  if (STATS)
  {
    drawGame();
    save("Data/screenshot.jpg");
    statsTemplate = loadImage("Data/screenshot.jpg");
    INGAME = false;
  }
}

public void checkGameOver()
{
  int tanksAlive = 0;
  for (Tank tank : tankList)
  {
    if (tank.alive)
    {
      tanksAlive++;
    }
  }
  if (tanksAlive <= 1)
  {
    for (Tank tank : tankList)
    {
      if (tank.alive)
      {
        tank.score +=1;
      }
    }
    if (gameOverTimer != 0)
    {
      gameOverTimer -= 1;
    } else
    {

      startNewGame();
      
    }
  }
}

 public void keyPressed()
{
  if (INGAME)
  {
    if (keyCode == RIGHT)
    {
      redTank.angleChange=ANGLESPEED;
      //predictiveTankCornerCollision(redTank);
    } else if (keyCode == LEFT)
    {
      redTank.angleChange=-ANGLESPEED;
      //predictiveTankCornerCollision(redTank);
    } else if (keyCode == UP)
    {
      redTank.speed = MOVE_SPEED;
    } else if (keyCode == DOWN)
    {
      redTank.speed = -MOVE_SPEED * 0.5f;
    }

    if (key == 'D' || key == 'd')
    {
      greenTank.angleChange=ANGLESPEED;
    } else if  (key == 'A' || key == 'a')
    {
      greenTank.angleChange=-ANGLESPEED;
    } else if (key == 'W' || key == 'w')
    {
      greenTank.speed = MOVE_SPEED;
    } else if (key == 'S' || key == 's')
    {
      greenTank.speed = -MOVE_SPEED * 0.5f;
    }

    if (key == '0' || key == 'M')
    {
      redTank.fire();
    }

    if (key == ' ')
    {
      greenTank.fire();
    }
    if (ORANGE)
    {
      if (key == 'L' || key == 'l')
      {
        orangeTank.angleChange=ANGLESPEED;
      } else if  (key == 'J' || key == 'j')
      {
        orangeTank.angleChange=-ANGLESPEED;
      } else if (key == 'I' || key == 'i')
      {
        orangeTank.speed = MOVE_SPEED;
      } else if (key == 'K' || key == 'k')
      {
        orangeTank.speed = -MOVE_SPEED * 0.5f;
      }
      if (key == '/' || key == '?')
      {
        orangeTank.fire();
      }
    }
  } else if (CONTROLS)
  {
    if (key == ' ')
    {
      if (!greenReady)
      {
      greenReady = true;
      minim.loadFile("Sounds/Click.mp3").play();
      }
    }
    if (ORANGE)
    {
      if (key == '/' || key == '?')
      {
        if (!orangeReady)
        {
        orangeReady = true;
        minim.loadFile("Sounds/Click.mp3").play();
        }
      }
    }

    if (key == '0' || key == 'M')
    {
      if (!redReady)
      {
      redReady = true;
     minim.loadFile("Sounds/Click.mp3").play();
      }
    }
  }
  else if (STATS)
  {
    if (key == ESC)
    {
      key = 0; //weird hack to prevent it from quitting the entire game
      STATS  =false;
      INGAME = true;
      minim.loadFile("Sounds/Click.mp3").play();
    }
  }
}

 public void keyReleased()
{
  if (INGAME)
  {
    if (keyCode == UP)
    {
      redTank.speed = 0;
    } else if (keyCode == DOWN)
    {
      redTank.speed = 0;
    } else if (keyCode == LEFT)
    {
      redTank.angleChange = 0;
    } else if (keyCode == RIGHT)
    {
      redTank.angleChange = 0;
    }

    if (key == 'D' || key == 'd')
    {
      greenTank.angleChange=0;
    } else if  (key == 'A' || key == 'a')
    {
      greenTank.angleChange=0;
    } else if (key == 'W' || key == 'w')
    {
      greenTank.speed = 0;
    } else if (key == 'S' || key == 's')
    {
      greenTank.speed = 0;
    }
    if (ORANGE)
    {
      if (key == 'L' || key == 'l')
      {
        orangeTank.angleChange=0;
      } else if  (key == 'J' || key == 'j')
      {
        orangeTank.angleChange=0;
      } else if (key == 'I' || key == 'i')
      {
        orangeTank.speed = 0;
      } else if (key == 'K' || key == 'k')
      {
        orangeTank.speed = 0;
      }
    }
  }
}

public void createMaze()
{

  maze = new Maze(HEIGHT/CELL_SIZE, WIDTH/CELL_SIZE); //Adaptive maze, screen size divided by the size of the cell
}

public void displayMaze()
{
  //draw the maze
  strokeWeight(1.2f);
  stroke(0xFF000000);
  line(0+OFFSETX, 0+OFFSETY, 0+OFFSETX, HEIGHT+OFFSETY);
  line(0+OFFSETX, 0+OFFSETY, WIDTH+OFFSETX, 0+OFFSETY);
  //line(WIDTH-1, 0, WIDTH-1, HEIGHT);
  for (Cell[] cells : maze.grid) {
    for (Cell cell : cells) {
      if (!cell.walls[3].isOpen) {
        line(cell.y * CELL_SIZE + CELL_SIZE+OFFSETX, cell.x * CELL_SIZE+OFFSETY, cell.y * CELL_SIZE + CELL_SIZE+OFFSETX, cell.x * CELL_SIZE + CELL_SIZE+OFFSETY);
      }

      if (!cell.walls[1].isOpen) {
        line(cell.y * CELL_SIZE+OFFSETX, cell.x * CELL_SIZE + CELL_SIZE+OFFSETY, cell.y * CELL_SIZE + CELL_SIZE+OFFSETX, cell.x * CELL_SIZE + CELL_SIZE+OFFSETY);
      }
    }
  }
}

public void displayPowerUps()
{
  strokeWeight(1.2f);
  stroke(0xFF000000);

  //line(WIDTH-1, 0, WIDTH-1, HEIGHT);
  for (Cell[] cells : maze.grid) {
    for (Cell cell : cells) {
      if (cell.powerUp != null)
      {
        cell.powerUp.display();
      }
    }
  }
}

public void bulletWallCollision()
{
  for (Tank tank : tankList)
  {
    ArrayList<Bullet> bulletList = tank.bulletList;
    for (Bullet bullet : bulletList)
    {
      //if (!bullet.checkCollision())
      //{
        int cellColumn = bullet.getColumn();
        int cellRow = bullet.getRow();

        if (DEBUG)
        {
          fill(0xFFFFA500, 75);
          noStroke();
          rect(cellColumn*CELL_SIZE, cellRow*CELL_SIZE, CELL_SIZE, CELL_SIZE);
        }
        try {
          Cell cell = maze.grid[cellRow][cellColumn];
          //ArrayList<Cell> cells = maze.getSurroundingCells(cellRow, cellColumn);
          //for (Cell cell: cells)
          //{
          //ArrayList<Line> lines = new ArrayList<Line>();
          float buffer = 10;
          if (!cell.walls[0].isOpen) //top
          {
            Line newLine = new Line(cell.left()-buffer, cell.top(), cell.right()+buffer, cell.top());
            if (linePoint(newLine, bullet.x, bullet.y, 1))
            {
              if (bullet.velocity.y<0)
              {
                if (bullet.isFrag)
                {
                  bullet.lifeTime = -1;
                }
                bullet.velocity.y = bullet.velocity.y * -1;
                bullet.playBounceSound();
              }
            }
          }
          if (!cell.walls[1].isOpen) //bottom
          {
            Line newLine = new Line(cell.left()-buffer, cell.bottom(), cell.right()+buffer, cell.bottom());
            if (linePoint(newLine, bullet.x, bullet.y, 1))
            {
              if (bullet.velocity.y>0)
              {
                if (bullet.isFrag)
                {
                  bullet.lifeTime = -1;
                }
                bullet.velocity.y = bullet.velocity.y * -1;
                bullet.playBounceSound();
              }
            }
          }
          /*aLine : lines)
           {
           
           if (DEBUG)
           {
           aLine.display();
           }
           }
           */

          //lines.clear();
          if (!cell.walls[3].isOpen) //right
          {
            Line newLine = new Line(cell.right(), cell.top()-buffer, cell.right(), cell.bottom()+buffer);
            if (bullet.velocity.x>0)
            {
              if (linePoint(newLine, bullet.x, bullet.y, 1))
              {
                if (bullet.isFrag)
                {
                  bullet.lifeTime = -1;
                }
                bullet.velocity.x= bullet.velocity.x * -1;
                bullet.bounceSound.play();
              }
            }
          }
          if (!cell.walls[2].isOpen) //left
          {
            Line newLine = new Line(cell.left(), cell.top()-buffer, cell.left(), cell.bottom()+buffer);
            if (bullet.velocity.x<0)
            {
              if (linePoint(newLine, bullet.x, bullet.y, 1))
              {
                if (bullet.isFrag)
                {
                  bullet.lifeTime = -1;
                }
                bullet.velocity.x= bullet.velocity.x * -1;
                bullet.bounceSound.play();
              }
            }
          }
          /*
          for (Line aLine : lines)
           {
           if (linePoint(aLine, bullet.x, bullet.y, 1))
           {
           bullet.velocity.x = bullet.velocity.x * -1;
           bullet.bounceSound.play();
           }
           if (DEBUG)
           {
           aLine.display();
           }
           
           }
           */
          //}
        }
        catch(Exception e)
        {
        }
      }
      //for collision with endpoints, the other axis vector needs to negatize
    //}
  }
}


public void tankBulletCollision()
{
  //ArrayList<Bullet> bulletList = greenTank.bulletList;
  //bulletList.addAll(redTank.bulletList);
  for (Tank tank : tankList)
  {
    if (tank.alive)
    {
      for (Tank tank2 : tankList)
      {
        ArrayList<Bullet> bulletList = tank2.bulletList;
        for (int i = 0; i < bulletList.size(); i++)
        {
          Bullet bullet = bulletList.get(i);
          float centerX2 = tank.centerX-1/6*tank.w;
          float bulletX = cos(tank.angle/360*TWO_PI) * (bullet.x - centerX2) -
            sin(tank.angle/360*TWO_PI) * (bullet.y - tank.centerY) + centerX2;
          float bulletY  = sin(tank.angle/360*TWO_PI) * (bullet.x - centerX2) +
            cos(tank.angle/360*TWO_PI) * (bullet.y - tank.centerY) + tank.centerY;

          // Closest point in the rectangle to the center of circle rotated backwards(unrotated)
          float closestX, closestY;

          // Find the unrotated closest x point from center of unrotated circle
          if (bulletX  < centerX2-tank.w*2/3/2)
            closestX = centerX2-tank.w*2/3/2;
          else if (bulletX  > centerX2 + tank.w*2/3/2)
            closestX = centerX2+tank.w*2/3/2;
          else
            closestX = bulletX;

          // Find the unrotated closest y point from center of unrotated circle
          if (bulletY < tank.centerY-tank.h/2)
            closestY = tank.centerY-tank.h/2;
          else if (bulletY > tank.centerY+tank.h/2)
            closestY = tank.centerY+tank.h/2;
          else
            closestY = bulletY;

          // Determine collision
          boolean collision = false;

          float distance = dist(bulletX, bulletY, closestX, closestY);
          if (distance < bullet.size/2)
          {
            collision = true; // Collision
            tank2.bulletList.remove(i);
            if (bullet == tank2.fragBomb)
            {
              tank2.fragBombExplode();
            }
            tank.kill(tank2);
            explosions.add(new Explosion(tank.centerX, tank.centerY));
          } else
            collision = false;
        }
      }
    }
  }
}

public void tankCornerCollision()
{

  ArrayList <Corner> corners = maze.corners;
  for (Tank tank : tankList)
  {
    if (tank.alive)
    {
      for (Corner corner : corners)
      {

        Line line;
        if (tank.speed < 0)
        {
          line = tank.getLeftLine();
        } else
        {
          line = tank.getRightLine();
        }
        float rad_angle = tank.angle/360*TWO_PI;

        if (linePoint(line, corner.x, corner.y, .8f)) //.8
        {

          //if (exactlyOneTrue(corner.left, corner.right, corner.top, corner.bottom))
          //{
          if (!corner.isRightCorner())
          {
            float velocityX = tank.speed*cos(rad_angle);
            float velocityY = tank.speed*sin(rad_angle);
            if (corner.top && velocityY < 0)//top
            {
              //tank.centerX -= tank.speed*cos(rad_angle);
              tank.centerY -= tank.speed*sin(rad_angle);
              //tank.centerY += corner.y - tank.getTop();
            }
            if (corner.bottom && velocityY > 0)
            {
              //tank.centerX -= tank.speed*cos(rad_angle);
              tank.centerY -= tank.speed*sin(rad_angle);
            }
            if (corner.left && velocityX < 0)
            {
              tank.centerX -= tank.speed*cos(rad_angle);
              //tank.centerY -= tank.speed*sin(rad_angle);
            }
            if (corner.right && velocityX > 0)
            {
              tank.centerX -= tank.speed*cos(rad_angle);
              //tank.centerY -= tank.speed*sin(rad_angle);
            }
          } else if (exactlyOneTrue(corner.left, corner.right, corner.top, corner.bottom))
          {
            float velocityX = tank.speed*cos(rad_angle);
            float velocityY = tank.speed*sin(rad_angle);
            if (corner.top && velocityY < 0)// && bullet.y - bullet.velocity.y > corner.y)
            {
              tank.centerX -= tank.speed*cos(rad_angle);
              tank.centerY -= tank.speed*sin(rad_angle);
            } else if (corner.bottom && velocityY > 0)
            {
              tank.centerX -= tank.speed*cos(rad_angle);
              tank.centerY -= tank.speed*sin(rad_angle);
            } else if (corner.left && velocityX < 0)
            {
              tank.centerX -= tank.speed*cos(rad_angle);
              tank.centerY -= tank.speed*sin(rad_angle);
            } else if (corner.right && velocityX > 0)
            {
              tank.centerX -= tank.speed*cos(rad_angle);
              tank.centerY -= tank.speed*sin(rad_angle);
            }
          }
          //}
        }





        line = tank.getTopLine();
        if (linePoint(line, corner.x, corner.y, 0.5f))
        {
          tank.angle -= tank.angleChange;
          //tank.angleChange = 0;
        }

        line = tank.getBottomLine();
        if (linePoint(line, corner.x, corner.y, 0.5f))
        {
          tank.angle -= tank.angleChange;
          //tank.angleChange = 0;
        }
      }
    }
  }
}



public boolean predictiveTankCornerCollision(Tank tank)
{
  ArrayList <Corner> corners = maze.corners;
  boolean collision = false;

  for (Corner corner : corners)
  {
    ArrayList<Line> tankLines = tank.getLines();
    tank.angle += tank.angleChange;
    tankLines = tank.getLines();
    /*
        for (Line line : tankLines)
     {
     if (linePoint(line, corner.x, corner.y, 0.1))
     {
     tank.angle-=tank.angleChange;
     tank.angleChange = 0;
     }
     }
     */
    float centerX2 = tank.centerX-1/6*tank.w;
    float bulletX = cos(tank.angle/360*TWO_PI) * (corner.x - centerX2) -
      sin(tank.angle/360*TWO_PI) * (corner.y - tank.centerY) + centerX2;
    float bulletY  = sin(tank.angle/360*TWO_PI) * (corner.x - centerX2) +
      cos(tank.angle/360*TWO_PI) * (corner.y - tank.centerY) + tank.centerY;

    // Closest point in the rectangle to the center of circle rotated backwards(unrotated)
    float closestX, closestY;

    // Find the unrotated closest x point from center of unrotated circle
    if (bulletX  < centerX2-tank.w*2/3/2)
      closestX = centerX2-tank.w*2/3/2;
    else if (bulletX  > centerX2 + tank.w*2/3/2)
      closestX = centerX2+tank.w*2/3/2;
    else
      closestX = bulletX;

    // Find the unrotated closest y point from center of unrotated circle
    if (bulletY < tank.centerY-tank.h/2)
      closestY = tank.centerY-tank.h/2;
    else if (bulletY > tank.centerY+tank.h/2)
      closestY = tank.centerY+tank.h/2;
    else
      closestY = bulletY;

    // Determine collision


    float distance = dist(bulletX, bulletY, closestX, closestY);
    if (distance < 1)
    {
      collision = true; // Collision
      tank.angle-=tank.angleChange;
      tank.angleChange = 0;
    } else
    {
      collision = false;
      tank.angle-=tank.angleChange;
    }
  }


  return collision;
}

public void bulletCornerCollision()
{
  ArrayList <Corner> corners = maze.corners;
  for (Tank tank : tankList)
  {
    ArrayList<Bullet> bulletList = tank.bulletList;
    for (Bullet bullet : bulletList)
    {
      for (Corner corner : corners)
      {

        float dist = dist(bullet.x, bullet.y, corner.x, corner.y);
        float threshold = bullet.size/2;
        if (bullet.isFrag)
        {
          threshold = 10;
        }
        if (dist < threshold)
        {

          if (exactlyOneTrue(corner.left, corner.right, corner.top, corner.bottom))
          {
            if (!bullet.isFrag)
            {
              if (corner.top && bullet.velocity.y < 0)// && bullet.y - bullet.velocity.y > corner.y)
              {
                bullet.velocity.y = bullet.velocity.y * -1;
              } else if (corner.bottom && bullet.velocity.y > 0)
              {
                bullet.velocity.y = bullet.velocity.y * -1;
              } else if (corner.left && bullet.velocity.x < 0)
              {
                bullet.velocity.x = bullet.velocity.x * -1;
              } else if (corner.right && bullet.velocity.x > 0)
              {
                bullet.velocity.x = bullet.velocity.x * -1;
              }
              bullet.playBounceSound();
            } else
            {
              bullet.lifeTime = -1;
            }
          }
          /*
          else if (corner.isStraight())
           {
           if (corner.left && corner.right)
           {
           bullet.velocity.y = bullet.velocity.y * -1;
           }
           else
           {
           bullet.velocity.x = bullet.velocity.x * -1;
           }
           }
           */
        }
      }
    }
  }
}

private boolean exactlyOneTrue(boolean b1, boolean b2, boolean b3, boolean b4)
{
  if (b1 && !b2 && !b3 && !b4)
  {
    return true;
  }
  if (!b1 && b2 && !b3 && !b4)
  {
    return true;
  }
  if (!b1 && !b2 && b3 && !b4)
  {
    return true;
  }
  if (!b1 && !b2 && !b3 && b4)
  {
    return true;
  }
  return false;
}

public void tankPowerUpCollision()
{
  for (Tank tank : tankList)
  {
    if (tank.alive)
    {
      //ArrayList<Line> tankLines = tank.getLines();

      ArrayList<Line> lines = new ArrayList<Line>();
      int cellColumn = tank.getColumn();
      int cellRow = tank.getRow();

      if (DEBUG)
      {
        if (tank.team.equals("red"))
          fill(0xFFFF0000, 25);
        else if (tank.team.equals("green"))
          fill(0xFF00FF00, 25);
        noStroke();
        rect(cellColumn*CELL_SIZE, cellRow*CELL_SIZE, CELL_SIZE, CELL_SIZE);
      }
      //ArrayList<Cell> cells = maze.getSurroundingCells(cellRow, cellColumn);
      //boolean collided = false;

      Cell cell = (maze.grid[cellRow][cellColumn]);


      //Cell cell = maze.grid[cellRow][cellColumn];
      PowerUp power = cell.powerUp;
      if (power != null && tank.power == null)
      {
        Line newLine = new Line(power.x-POWERSIZE, power.y-POWERSIZE, power.x+POWERSIZE, power.y-POWERSIZE); //top
        lines.add(newLine);
        newLine = new Line(power.x-POWERSIZE, power.y-POWERSIZE, power.x-POWERSIZE, power.y+POWERSIZE); //left
        lines.add(newLine);
        newLine = new Line(power.x+POWERSIZE, power.y-POWERSIZE, power.x+POWERSIZE, power.y+POWERSIZE); //right
        lines.add(newLine);
        newLine = new Line(power.x-POWERSIZE, power.y+POWERSIZE, power.x+POWERSIZE, power.y+POWERSIZE); //bottom
        lines.add(newLine);


        for (Line aLine : lines)
        {

          if (lineRect(aLine, tank.getTopLine(), tank.getBottomLine(), tank.getLeftLine(), tank.getRightLine()))
          {
            tank.power = power;
            tank.powerUpsCollected++;
            if (power.type.equals("Laser"))
            {
              tank.laser = new Laser(tank.centerX, tank.centerY, tank.angle, tank.w, tank.h, tank.laserFireSound, tank);
            }
            cell.powerUp = null;
            power.playCollectSound();
            POWERCOUNT-=1;
          }
          if (DEBUG)
          {
            aLine.display();
          }
        }
      }
    }
  }
}

public void tankWallCollision()
{

  for (Tank tank : tankList)
  {
    if (tank.alive)
    {

      ArrayList<Line> lines = new ArrayList<Line>();
      int cellColumn = tank.getColumn();
      int cellRow = tank.getRow();

      if (DEBUG)
      {
        if (tank.team.equals("red"))
          fill(0xFFFF0000, 25);
        else if (tank.team.equals("green"))
          fill(0xFF00FF00, 25);
        noStroke();
        rect(cellColumn*CELL_SIZE, cellRow*CELL_SIZE, CELL_SIZE, CELL_SIZE);
      }
      ArrayList<Cell> cells = maze.getSurroundingCells(cellRow, cellColumn);


      for (Cell cell : cells)
      {

        if (!cell.walls[0].isOpen) //top
        {
          Line newLine = new Line(cell.left(), cell.top(), cell.right(), cell.top());
          lines.add(newLine);
        }
        if (!cell.walls[1].isOpen) //bottom
        {
          Line newLine = new Line(cell.left(), cell.bottom(), cell.right(), cell.bottom());
          lines.add(newLine);
        }

        if (!cell.walls[3].isOpen) //right
        {
          Line newLine = new Line(cell.right(), cell.top(), cell.right(), cell.bottom());
          lines.add(newLine);
        }
        if (!cell.walls[2].isOpen) //left
        {
          Line newLine = new Line(cell.left(), cell.top(), cell.left(), cell.bottom());
          lines.add(newLine);
        }
      }

      for (int i = 0; i < lines.size(); i++)
      {
        for (int j = i+1; j < lines.size(); j++)
        {
          if (lines.get(i).equals(lines.get(j)))
          {
            lines.remove(j);
          }
        }
      }

      boolean verticalCol = false;
      boolean horizontalCol = false;
      for (Line aLine : lines)
      {

        if (lineRect(aLine, tank.getTopLine(), tank.getBottomLine(), tank.getLeftLine(), tank.getRightLine()))

        {


          //aLine.display(#00FF00);

          float lineTop = min(aLine.y1, aLine.y2);
          float lineBottom = max(aLine.y1, aLine.y2);
          float lineRight =max(aLine.x1, aLine.x2);
          float lineLeft = min(aLine.x1, aLine.x2);

          float rad_angle = tank.angle/360*TWO_PI;
          int BUFFER= 5;
          if (aLine.isVertical && !verticalCol)
          {

            if (tank.getBottom()-BUFFER <= lineTop && tank.centerY < lineTop) //top
            {
              tank.centerY -= abs(lineTop - tank.getBottom());
              //println("TOP");
              verticalCol = true;
            } else if (tank.getTop()+BUFFER >= lineBottom)//bottom
            {
              tank.centerY += abs(lineBottom - tank.getTop());
              //println("TOP");
              verticalCol = true;
            } else if (tank.getLeft() <= lineLeft && tank.centerX > lineLeft) //left
            {
              tank.centerX += abs(lineLeft - tank.getLeft());
              tank.centerY -= tank.speed*sin(rad_angle)*0.5f;
              //println("LEFT");
              verticalCol = true;
            } else if (tank.getRight() >= lineRight && tank.centerX < lineRight) //right
            {
              tank.centerX -= abs(lineRight-tank.getRight());

              tank.centerY -= tank.speed*sin(rad_angle)*0.5f;
              //println("RIGHT");
              verticalCol = true;
            }
          } else if (aLine.isHorizental && !horizontalCol)
          {
            if (tank.getRight()-BUFFER <= lineLeft && tank.centerX < lineLeft) //left
            {
              tank.centerX -= abs(lineLeft - tank.getRight());
              //println("LEFT");
              horizontalCol = true;
            } else if (tank.getLeft()+BUFFER >= lineRight) //right
            {
              tank.centerX += abs(lineRight - tank.getLeft());
              //println("RIGHT");
              horizontalCol = true;
            } else if (tank.getTop() <= lineTop && tank.centerY > lineTop) //TOP
            {
              tank.centerY += abs(lineTop - tank.getTop());

              tank.centerX -= tank.speed*cos(rad_angle)*0.5f;
              //println("TOP");
              horizontalCol = true;
            } else if (tank.getBottom() >= lineBottom && tank.centerY < lineBottom) //BOTTOM
            {
              tank.centerY -= abs(lineBottom-tank.getBottom());

              tank.centerX -= tank.speed*cos(rad_angle)*0.5f;
              //println("BOTTOM");
              horizontalCol = true;
            }
          }
          float t = random(.4f, .6f);
          float x = tank.getLeftLine().lerpX(t) - cos(tank.angle/360*TWO_PI)*(tank.w/10);
          float y = tank.getLeftLine().lerpY(t) - sin(tank.angle/360*TWO_PI)*(tank.w/10);
          ;
          drawSmoke(x, y, 15, tank);
        } else
        {
          //println("NO COL");
        }
      }
      if (DEBUG)
      {
        for (Line line : lines)
        {
          line.display();
        }
      }
      /*
      if (!collided)
       {
       tankCornerCollision();
       }
       */
    }
  }
}




public boolean laserCollision(Laser bullet)
{
  /*
  if ((bullet.x > WIDTH) || (bullet.x < 0))
   {
   bullet.velocity.x = bullet.velocity.x * -1;
   
   return true;
   }
   if (bullet.y > HEIGHT || bullet.y < 0)
   {
   bullet.velocity.y = bullet.velocity.y * -1;
   return true;
   }
   */

  int cellColumn = bullet.getColumn();
  int cellRow = bullet.getRow();



  if (DEBUG)
  {
    fill(0xFFFFA500, 75);
    noStroke();
    rect(cellColumn*CELL_SIZE, cellRow*CELL_SIZE, CELL_SIZE, CELL_SIZE);
  }

  try {
    Cell cell = maze.grid[cellRow][cellColumn];

    if (!cell.walls[0].isOpen) //top
    {
      Line newLine = new Line(cell.left(), cell.top(), cell.right(), cell.top());
      if (linePoint(newLine, bullet.laserEnd.x, bullet.laserEnd.y, 0.8f))
      {
        if (bullet.velocity.y<0)
        {
          bullet.velocity.y = bullet.velocity.y * -1;
          return true;
        }
      }
    }
    if (!cell.walls[1].isOpen) //bottom
    {
      Line newLine = new Line(cell.left(), cell.bottom(), cell.right(), cell.bottom());
      if (linePoint(newLine, bullet.laserEnd.x, bullet.laserEnd.y, 0.8f))
      {
        if (bullet.velocity.y>0)
        {
          bullet.velocity.y = bullet.velocity.y * -1;
          return true;
        }
      }
    }

    if (!cell.walls[3].isOpen) //right
    {
      Line newLine = new Line(cell.right(), cell.top(), cell.right(), cell.bottom());

      if (bullet.velocity.x>0)
      {
        if (linePoint(newLine, bullet.laserEnd.x, bullet.laserEnd.y, 0.8f))
        {
          bullet.velocity.x= bullet.velocity.x * -1;
          return true;
        }
      }
    }

    if (!cell.walls[2].isOpen) //left
    {
      Line newLine = new Line(cell.left(), cell.top(), cell.left(), cell.bottom());
      if (bullet.velocity.x<0)
      {
        if (linePoint(newLine, bullet.laserEnd.x, bullet.laserEnd.y, 0.2f))
        {
          bullet.velocity.x= bullet.velocity.x * -1;
          return true;
        }
      }
    }
  }
  catch(Exception e)
  {
    //println(e);
  }
  return laserCorner(bullet);
}

 public boolean laserCorner(Laser bullet)
{
  ArrayList <Corner> corners = maze.corners;

  for (Corner corner : corners)
  {
    //float yDist = abs(corner.y-bullet.y);
    //float xDist = abs(corner.x-bullet.x);
    float dist = dist(bullet.x, bullet.y, corner.x, corner.y);
    if (dist < bullet.size/2)
    {


      if (exactlyOneTrue(corner.left, corner.right, corner.top, corner.bottom))
      {

        if (corner.top && bullet.velocity.y < 0)// && bullet.y - bullet.velocity.y > corner.y)
        {
          bullet.velocity.y = bullet.velocity.y * -1;
        } else if (corner.bottom && bullet.velocity.y > 0)
        {
          bullet.velocity.y = bullet.velocity.y * -1;
        } else if (corner.left && bullet.velocity.x < 0)
        {
          bullet.velocity.x = bullet.velocity.x * -1;
        } else if (corner.right && bullet.velocity.x > 0)
        {
          bullet.velocity.x = bullet.velocity.x * -1;
        }
        return true;
      }
    }
  }
  return false;
}



 public boolean laserTankCollision(Laser laser, boolean fire)
{
  for (Tank tank : tankList)
  {
    if (tank.alive)
    {

      for (Line tankLine : tank.getLines())
      {
        for (Line laserLine : laser.lineList)
        {
          if (lineLine(tankLine, laserLine))
          {
            if (fire)
            {
              tank.kill(laser.firedTank);
              explosions.add(new Explosion(tank.centerX, tank.centerY));
            }
            return true;
          }
        }
      }
    }
  }
  return false;
}


// LINE/POINT
 public boolean linePoint(Line line, float px, float py, float buffer) {

  float x1 = line.x1;
  float y1 = line.y1;
  float x2 = line.x2;
  float y2 = line.y2;

  // get distance from the point to the two ends of the line
  float d1 = dist(px, py, x1, y1);
  float d2 = dist(px, py, x2, y2);

  // get the length of the line
  float lineLen = dist(x1, y1, x2, y2);

  // since floats are so minutely accurate, add
  // a little buffer zone that will give collision
  //float buffer = 2;    // higher # = less accurate

  // if the two distances are equal to the line's
  // length, the point is on the line!
  // note we use the buffer here to give a range,
  // rather than one #
  if (d1+d2 >= lineLen-buffer && d1+d2 <= lineLen+buffer) {
    return true;
  }
  return false;
}

// LINE/RECTANGLE
 public boolean lineRect(Line wall, Line line1, Line line2, Line line3, Line line4) {

  // check if the line has hit any of the rectangle's sides
  // uses the Line/Line function below
  boolean left =   lineLine(wall, line1);
  boolean right =  lineLine(wall, line2);
  boolean top =    lineLine(wall, line3);
  boolean bottom = lineLine(wall, line4);

  // if ANY of the above are true, the line
  // has hit the rectangle
  if (left || right || top || bottom) {
    return true;
  }
  return false;
}

public void getTargetTank(Missle missle)
{
  for (Tank tank : tankList)
  {
    if (missle.targetX != -1)
    {
      if (tank.alive)
      {
        if (tank.getColumn() == missle.targetY && tank.getRow() == missle.targetX)
        {

          missle.targetTank = tank;
        }
      }
    }
  }
}

// LINE/LINE
 public boolean lineLine(Line line1, Line line2) {
  float x1, x2, x3, x4, y1, y2, y3, y4;
  x1 = line1.x1;
  y1 = line1.y1;
  x2 = line1.x2;
  y2 = line1.y2;
  x3 = line2.x1;
  y3 = line2.y1;
  x4 = line2.x2;
  y4 = line2.y2;

  // calculate the direction of the lines
  float uA = ((x4-x3)*(y1-y3) - (y4-y3)*(x1-x3)) / ((y4-y3)*(x2-x1) - (x4-x3)*(y2-y1));
  float uB = ((x2-x1)*(y1-y3) - (y2-y1)*(x1-x3)) / ((y4-y3)*(x2-x1) - (x4-x3)*(y2-y1));

  // if uA and uB are between 0-1, lines are colliding
  if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {

    // optionally, draw a circle where the lines meet
    //float intersectionX = x1 + (uA * (x2-x1));
    //float intersectionY = y1 + (uA * (y2-y1));
    //fill(255, 0, 0);
    //noStroke();
    //ellipse(intersectionX, intersectionY, 20, 20);

    return true;
  }
  return false;
}


public  Cell getPathBFS(int x, int y)

{
  q.clear();
  maze.clearVisited();
  q.add(maze.grid[y][x]);
  while (!q.isEmpty()) {
    Cell p = q.remove();


    boolean top = false;
    boolean bottom = false;
    boolean right = false;
    boolean left = false;

    int px = p.y;
    int py = p.x;
    //px and py are actual x/y place
    //p.x is row (y)
    //p.y is column (x)

    if (maze.grid[py][px].walls[0].isOpen && maze.grid[py-1][px].walls[1].isOpen)
      top = true;
    if (maze.grid[py][px].walls[1].isOpen && maze.grid[py+1][px].walls[0].isOpen)
      bottom = true;
    if (maze.grid[py][px].walls[3].isOpen && maze.grid[py][px+1].walls[2].isOpen)
      right = true;
    if (maze.grid[py][px].walls[2].isOpen && maze.grid[py][px-1].walls[3].isOpen)
      left = true;


    for (Tank tank : tankList) {
      if (tank.alive)
      {
        if (tank.getRow() == py && tank.getColumn() == px)
        {
          System.out.println("Exit is reached!");
          return p;
        }
      }
    }

    if (right && isFree(px+1, py)) { //can go right
      maze.grid[py][px].visited = true;
      Cell nextP = maze.grid[py][px+1];
      nextP.parent = p;
      q.add(nextP);
    }
    if (left && isFree(px-1, py)) { //can go left
      maze.grid[py][px].visited = true;
      Cell nextP = maze.grid[py][px-1];

      nextP.parent = p;
      q.add(nextP);
    }
    if (top && isFree(px, py-1)) { //can go up
      maze.grid[py][px].visited = true;
      Cell nextP = maze.grid[py-1][px];
      nextP.parent = p;
      q.add(nextP);
    }
    if (bottom && isFree(px, py+1)) { //can go dpwm
      maze.grid[py][px].visited = true;
      Cell nextP = maze.grid[py+1][px];
      nextP.parent = p;
      q.add(nextP);
    }
  }
  return null;
}



public  boolean isFree(int x, int y) {
  if ((x >= 0 && x < WIDTH/CELL_SIZE) && (y >= 0 && y < HEIGHT/CELL_SIZE) && (maze.grid[y][x].visited == false))
  {
    return true;
  }
  return false;
}

public void missleWallCollision()
{

  //Missle missle = testMissle;
  //ArrayList<Line> tankLines = tank.getLines();
  for (Tank tank : tankList)
  {
    if (tank.missle != null)
    {

      Missle missle = tank.missle;

      Line frontLine = missle.getRightLine();
      float midX = (frontLine.x1+frontLine.x2)/2;
      float midY = (frontLine.y1+frontLine.y2)/2;




      if (15 < missle.lifeTime && missle.lifeTime < TIMEBEFORETRACK)
      {
        missleTankCollision(missle);
      }
      float rad_angle = missle.angle/360*TWO_PI;
      float xVelocity = cos(rad_angle);
      float yVelocity =  sin(rad_angle);

      




      ArrayList<Line> lines = new ArrayList<Line>();
      ArrayList<Line> lines2 = new ArrayList<Line>();
      int cellColumn = missle.getColumn();
      int cellRow = missle.getRow();


      Cell cell2 = (maze.grid[cellRow][cellColumn]);
      ArrayList<Cell> cells = maze.getSurroundingCells(cellRow, cellColumn);

      for (Cell cell : cells)
      {

        float buffer = 5;
        if (!cell.walls[0].isOpen) //top
        {
          Line newLine = new Line(cell.left()-buffer, cell.top(), cell.right()+buffer, cell.top());
          lines.add(newLine);
          lines2.add(newLine);
          //newLine.display();
        }
        if (!cell.walls[1].isOpen) //bottom
        {
          Line newLine = new Line(cell.left()-buffer, cell.bottom(), cell.right()+buffer, cell.bottom());
          lines.add(newLine);
          lines2.add(newLine);
          //newLine.display();
        }

        if (!cell.walls[3].isOpen) //right
        {
          Line newLine = new Line(cell.right(), cell.top()-buffer, cell.right(), cell.bottom()+buffer);
          lines.add(newLine);
          lines2.add(newLine);
          //newLine.display();
        }
        if (!cell.walls[2].isOpen) //left
        {
          Line newLine = new Line(cell.left(), cell.top()-buffer, cell.left(), cell.bottom()+buffer);
          lines.add(newLine);
          lines2.add(newLine);
          //newLine.display();
        }
      }
      for (int i = 0; i < lines.size(); i++)
      {
        for (int j = i+1; j < lines.size(); j++)
        {
          if (lines.get(i).equals(lines.get(j)))
          {
            lines.remove(j);
          }
        }
      }

      for (Line aLine : lines)
      {

        //0 - right
        //90 - down
        //180 - left
        //270 - up
        
        if (lineLine(aLine, frontLine) || linePoint(aLine, midX, midY, 0.1f))
        {
    
          //if ((midX > cell2.right()-4) || (midX < cell2.left()+4))
          if (aLine.isVertical)
          {
            xVelocity = -1*xVelocity;
            missle.angle = atan2(yVelocity, xVelocity)*180/PI;
            // missle.display();
          } //else if (midY > cell2.top()+4 || midY < cell2.bottom()-4)
          else if (aLine.isHorizental)
          {

            yVelocity = -1*yVelocity;
            missle.angle = atan2(yVelocity, xVelocity)*180/PI;
            if (missle.angle < 0)
            {
              missle.angle = missle.angle +360;
            }
            //missle.display();
          } 
          break;
            
        }

        if (DEBUG)
        {
          aLine.display();
        }
        // }
      }
    }
  }
}



 public void missleTankCollision(Missle missle)
{
  for (Tank tank : tankList)
  {
    if (tank.alive)
    {
      for (Line line : missle.getLines()) 
      {
        if (lineRect(line, tank.getTopLine(), tank.getBottomLine(), tank.getLeftLine(), tank.getRightLine()))
        {
          tank.kill(missle.firedTank);
          explosions.add(new Explosion(tank.centerX, tank.centerY));
          missle.lifeTime = 5000;
        }
      }
    }
  }
}

 public void barrelWallCollision()
{
  for (Tank tank : tankList)
  {
    if (tank.alive)
    {
      Line barrel;
      if (tank.power!= null && tank.power.type == "Missle")
      {
        barrel = tank.getBarrel(true);
      } else
      {
        barrel = tank.getBarrel(false);
      }

      ArrayList<Line> lines = new ArrayList<Line>();
      int cellColumn = tank.getColumn();
      int cellRow = tank.getRow();

      if (DEBUG)
      {
        if (tank.team.equals("red"))
          fill(0xFFFF0000, 25);
        else if (tank.team.equals("green"))
          fill(0xFF00FF00, 25);
        noStroke();
        rect(cellColumn*CELL_SIZE, cellRow*CELL_SIZE, CELL_SIZE, CELL_SIZE);
      }

      Cell cell = (maze.grid[cellRow][cellColumn]);


      //Cell cell = maze.grid[cellRow][cellColumn];
      if (!cell.walls[0].isOpen) //top
      {
        Line newLine = new Line(cell.left(), cell.top(), cell.right(), cell.top());
        lines.add(newLine);
      }
      if (!cell.walls[1].isOpen) //bottom
      {
        Line newLine = new Line(cell.left(), cell.bottom(), cell.right(), cell.bottom());
        lines.add(newLine);
      }

      if (!cell.walls[3].isOpen) //right
      {
        Line newLine = new Line(cell.right(), cell.top(), cell.right(), cell.bottom());
        lines.add(newLine);
      }
      if (!cell.walls[2].isOpen) //left
      {
        Line newLine = new Line(cell.left(), cell.top(), cell.left(), cell.bottom());
        lines.add(newLine);
      }

      for (Line aLine : lines)
      {
        if (lineLine(aLine, barrel))
        {
          tank.onWall = true;
          break;
        } else
        {
          tank.onWall = false;
        }
      }
    }
  }
}

public void updateBeam(Beam beam)
{
  //https://stackoverflow.com/a/6853926
  if (beam.time == 0)
  {
    float MAXANGLE = .12f; //7 degrees
    float minDist = 20000;
    float minXX=0;
    float minYY = 0;
    Tank targetTank = null;
    for (Tank tank : tankList)
    {
      if (tank.team != beam.firedTank.team && tank.alive)
      {

        float A = tank.centerX - beam.line.x1;
        float B = tank.centerY - beam.line.y1;
        float C = beam.line.x2 - beam.line.x1;
        float D = beam.line.y2 - beam.line.y1;

        float dot = A * C + B * D;
        float len_sq = C * C + D * D;
        float param = -1;
        if (len_sq != 0) //in case of 0 length line
          param = dot/len_sq;

        float xx, yy;
        xx = -1;
        yy = -1;
        if (param < 0) {
          //xx = beam.line.x1;
          //yy = beam.line.y1;
        } else if (param > 1) {
          //xx = beam.line.x2;
          //yy = beam.line.y1;
        } else {
          xx = beam.line.x1 + param * C;
          yy = beam.line.y1 + param * D;
        }

        float dx = tank.centerX - xx;
        float dy = tank.centerY - yy;
        if (Math.sqrt(dx * dx + dy * dy) < minDist)
        {
          minDist = sqrt(dx * dx + dy * dy);
          targetTank = tank;
          minXX = xx;
          minYY = yy;
        }
        float angle = atan(dist(minXX, minYY, targetTank.centerX, targetTank.centerY)/dist(beam.firedTank.centerX, beam.firedTank.centerY, minXX, minYY));
        if (angle < MAXANGLE) //3 degrees
        {
          float controlPointX = beam.firedTank.centerX;
          float controlPointY = beam.firedTank.centerY;
          float controlPointX2 = (beam.firedTank.centerX+minXX)/2;
          float controlPointY2 = (beam.firedTank.centerY+minYY)/2;
          //Line line = new Line(minXX, minYY, targetTank.centerX, targetTank.centerY);
          ellipse(controlPointX, controlPointY, 5, 5);
          noFill();
          Float bezierPoints[] = {beam.firedTank.centerX+cos(beam.angle/360*TWO_PI)*(beam.w/2), beam.firedTank.centerY+sin(beam.angle/360*TWO_PI)*(beam.w/2), controlPointX, controlPointY, controlPointX2, controlPointY2, targetTank.centerX, targetTank.centerY};
          //bezier(bezierPoints[0],bezierPoints[1],bezierPoints[2],bezierPoints[3],bezierPoints[4],bezierPoints[5],bezierPoints[6],bezierPoints[7]);
          //line.display();
          //beam.line.display();

          float tx = bezierTangent(beam.firedTank.centerX, controlPointX, controlPointX2, targetTank.centerX, 1);
          float ty = bezierTangent(beam.firedTank.centerY, controlPointY, controlPointY2, targetTank.centerY, 1);


          float a = atan2(ty, tx);
          a += PI;
          Line line2 = new Line(targetTank.centerX, targetTank.centerY, cos(a)*-1400+targetTank.centerX, sin(a)*-1400+targetTank.centerY);
          //line2.display();
          beam.bezierPoints = bezierPoints;
          beam.bezier2 = line2;
        } else if (angle < .25f)
        {
          float targetDist = sqrt((minXX-beam.firedTank.centerX)*(minXX-beam.firedTank.centerX)+(minYY-beam.firedTank.centerY)*(minYY-beam.firedTank.centerY))*tan(MAXANGLE);

          dx = targetTank.centerX-minXX;
          dy = targetTank.centerY-minYY;
          float dist = sqrt(dx*dx+dy*dy);
          float ratio = targetDist/dist;

          float controlPointX = beam.firedTank.centerX;
          float controlPointY = beam.firedTank.centerY;
          float controlPointX2 = (beam.firedTank.centerX+minXX)/2;
          float controlPointY2 = (beam.firedTank.centerY+minYY)/2;
          Float bezierPoints[] = {beam.firedTank.centerX+cos(beam.angle/360*TWO_PI)*(beam.w/2), beam.firedTank.centerY+sin(beam.angle/360*TWO_PI)*(beam.w/2), controlPointX, controlPointY, controlPointX2, controlPointY2, minXX+dx*ratio, minYY+dy*ratio};

          float tx = bezierTangent(beam.firedTank.centerX, controlPointX, controlPointX2, minXX+dx*ratio, 1);
          float ty = bezierTangent(beam.firedTank.centerY, controlPointY, controlPointY2, minYY+dy*ratio, 1);


          float a = atan2(ty, tx);
          a += PI;
          Line line2 = new Line(minXX+dx*ratio, minYY+dy*ratio, cos(a)*-1400+minXX+dx*ratio, sin(a)*-1400+ minYY+dy*ratio);
          beam.bezierPoints = bezierPoints;
          beam.bezier2 = line2;
        }
      }
    }
  }
}

public void beamCollision(Beam beam)
{
  if (beam.time > 45)
  {
    for (int i = 0; i < 100; i+=2)
    {
      float t = i/100.0f;
      float x, y;
      if (beam.bezier2 != null)
      {
        for (Tank tank : tankList)
        {
          if (tank.alive && beam.firedTank != tank)
          {
            x = beam.bezier2.lerpX(t);
            y = beam.bezier2.lerpY(t);
            float centerX2 = tank.centerX-1/6*tank.w;
            float bulletX = cos(tank.angle/360*TWO_PI) * (x - centerX2) -
              sin(tank.angle/360*TWO_PI) * (y - tank.centerY) + centerX2;
            float bulletY  = sin(tank.angle/360*TWO_PI) * (x - centerX2) +
              cos(tank.angle/360*TWO_PI) * (y - tank.centerY) + tank.centerY;

            // Closest point in the rectangle to the center of circle rotated backwards(unrotated)
            float closestX, closestY;

            // Find the unrotated closest x point from center of unrotated circle
            if (bulletX  < centerX2-tank.w*2/3/2)
              closestX = centerX2-tank.w*2/3/2;
            else if (bulletX  > centerX2 + tank.w*2/3/2)
              closestX = centerX2+tank.w*2/3/2;
            else
              closestX = bulletX;

            // Find the unrotated closest y point from center of unrotated circle
            if (bulletY < tank.centerY-tank.h/2)
              closestY = tank.centerY-tank.h/2;
            else if (bulletY > tank.centerY+tank.h/2)
              closestY = tank.centerY+tank.h/2;
            else
              closestY = bulletY;

            // Determine collision
            boolean collision = false;

            float distance = dist(bulletX, bulletY, closestX, closestY);
            if (distance < 7/2)
            {
              collision = true; // Collision
              tank.kill(beam.firedTank);
              explosions.add(new Explosion(tank.centerX, tank.centerY));
              break;
            } else
              collision = false;
          }
        }
      }

      if (beam.bezierPoints != null)
      {
        for (Tank tank : tankList)
        {
          if (tank.alive && beam.firedTank != tank)
          {
            x = bezierPoint(beam.bezierPoints[0], beam. bezierPoints[2], beam.bezierPoints[4], beam.bezierPoints[6], t);
            y = bezierPoint(beam.bezierPoints[1], beam.bezierPoints[3], beam.bezierPoints[5], beam.bezierPoints[7], t);

            float centerX2 = tank.centerX-1/6*tank.w;
            float bulletX = cos(tank.angle/360*TWO_PI) * (x - centerX2) -
              sin(tank.angle/360*TWO_PI) * (y - tank.centerY) + centerX2;
            float bulletY  = sin(tank.angle/360*TWO_PI) * (x - centerX2) +
              cos(tank.angle/360*TWO_PI) * (y - tank.centerY) + tank.centerY;

            // Closest point in the rectangle to the center of circle rotated backwards(unrotated)
            float closestX, closestY;

            // Find the unrotated closest x point from center of unrotated circle
            if (bulletX  < centerX2-tank.w*2/3/2)
              closestX = centerX2-tank.w*2/3/2;
            else if (bulletX  > centerX2 + tank.w*2/3/2)
              closestX = centerX2+tank.w*2/3/2;
            else
              closestX = bulletX;

            // Find the unrotated closest y point from center of unrotated circle
            if (bulletY < tank.centerY-tank.h/2)
              closestY = tank.centerY-tank.h/2;
            else if (bulletY > tank.centerY+tank.h/2)
              closestY = tank.centerY+tank.h/2;
            else
              closestY = bulletY;

            // Determine collision
            boolean collision = false;

            float distance = dist(bulletX, bulletY, closestX, closestY);
            if (distance < 7/2)
            {
              collision = true; // Collision
              tank.kill(beam.firedTank);
              explosions.add(new Explosion(tank.centerX, tank.centerY));
              break;
            } else
              collision = false;
          }
        }
      } else
      {
        x = beam.line.lerpX(t);
        y = beam.line.lerpY(t);
        for (Tank tank : tankList)
        {
          if (tank.alive && beam.firedTank != tank)
          {
            x = beam.line.lerpX(t);
            y = beam.line.lerpY(t);

            float centerX2 = tank.centerX-1/6*tank.w;
            float bulletX = cos(tank.angle/360*TWO_PI) * (x - centerX2) -
              sin(tank.angle/360*TWO_PI) * (y - tank.centerY) + centerX2;
            float bulletY  = sin(tank.angle/360*TWO_PI) * (x - centerX2) +
              cos(tank.angle/360*TWO_PI) * (y - tank.centerY) + tank.centerY;

            // Closest point in the rectangle to the center of circle rotated backwards(unrotated)
            float closestX, closestY;

            // Find the unrotated closest x point from center of unrotated circle
            if (bulletX  < centerX2-tank.w*2/3/2)
              closestX = centerX2-tank.w*2/3/2;
            else if (bulletX  > centerX2 + tank.w*2/3/2)
              closestX = centerX2+tank.w*2/3/2;
            else
              closestX = bulletX;

            // Find the unrotated closest y point from center of unrotated circle
            if (bulletY < tank.centerY-tank.h/2)
              closestY = tank.centerY-tank.h/2;
            else if (bulletY > tank.centerY+tank.h/2)
              closestY = tank.centerY+tank.h/2;
            else
              closestY = bulletY;

            // Determine collision
            boolean collision = false;

            float distance = dist(bulletX, bulletY, closestX, closestY);
            if (distance < 7/2)
            {
              collision = true; // Collision
              tank.kill(beam.firedTank);
              explosions.add(new Explosion(tank.centerX, tank.centerY));
              break;
            } else
              collision = false;
          }
        }
      }
    }
  }
}


public void drawStats()
{
tint(255, 80);
  image(statsTemplate, 1200/2, 900/2);
tint(255, 255);
  float inBetween = (1200.0f+200)/(tankList.size()+1);
  float y = 450;
  for (int i = 0; i < tankList.size(); i++)
  {
    Tank tank = tankList.get(i);

    float x = (i+1)*inBetween-100;
    if (tank.team.equals("Green"))
    {
      image(greenStats, x, y);
    } else if (tank.team.equals("Red"))
    {
      image(redStats, x, y);
    } else if (tank.team.equals("Blue"))
    {
      image(blueStats, x, y);
    } else if (tank.team.equals("Orange"))
    {
      image(orangeStats, x, y);
    }


    fill(0xFF000000);
    float textOffset =90;
    float lineHeight = 40;
    textFont(regular, 16);
    textAlign(LEFT);
    String text = "";
    int index = 0;
    for (Tank tank2 : tankList)
    {
      if (tank2.team != tank.team)
      {
        text=text+String.format("%-11s", tank2.team);
        textFont(bold, 30);
        textAlign(CENTER);
        text(tank.getKills(tank2), x-70+index*65, y-95);
        index++;
        textFont(regular, 16);
        textAlign(LEFT);
      }
    }
    text(text, x-90, y-70);

    textAlign(RIGHT);
    textFont(bold, 30);
    text(tank.getKills(tank), x+textOffset, y-15); //suicides
    text(tank.getKD(), x+textOffset, y-15+lineHeight); //KD
    text(tank.bulletsFired, x+textOffset, y-15+lineHeight*2); //bullets fired
    text(tank.getAccuracy(), x+textOffset+5, y-15+lineHeight*3); //accuracy
    textFont(bold, 15);
    text("%", x+textOffset+5, y-15+lineHeight*3);
    textFont(bold, 30);
    text(tank.powerUpsCollected, x+textOffset, y-15+lineHeight*4.1f); //power ups collected
    text(tank.fumbles, x+textOffset, y-15+lineHeight*5.1f); //fumbles
    drawBarChart(tank, x, y+205);
  }

  textFont(bold, 90);
  textAlign(CENTER);
  text(totalGames-1, 410, 120);
  int milliseconds = millis()-startTime;
  int seconds = (int) (milliseconds / 1000) % 60 ;
  int minutes = (int) ((milliseconds / (1000*60)) % 60);
  int hours   = (int) ((milliseconds / (1000*60*60)) % 24);
  text(String.format("%01d:%02d:%02d", hours, minutes, seconds), 750, 120);
  textFont(bold, 30);
  text("Games Played", 410, 150);
  text("Time Played", 750, 150);


  textAlign(LEFT);
  fill(0xFF000000);
  textFont(regular, 18);
  textSize(18);
  text("ESC to exit", 20, 30);
  //text("FPS: " + String.format("%.01f", frameRate), 1110, 880);
  
}

 public void drawSmoke(float centerX, float centerY, float R, Tank tank)
{
  float r = R * sqrt(random(0, 1));
  float theta = random(0, 1) * 2 * PI;
  float x = centerX + r * cos(theta);
  float y = centerY + r * sin(theta);
  float opacity = random(120, 180);
  float smokeRadius = random(8, 15);

  if (tank.smokeList.size()< 20 && frameCount%2==0)
  {
    tank.smokeList.add(new Smoke(x, y, smokeRadius, opacity));
  }
}

 public void drawBarChart(Tank tank, float x, float y)
{
  fill(0xFF414141);
  float chartWidth = tankList.size()*(8+5);

  x = x-chartWidth/2;
  float maxHeight = 35.0f;
  for (int i = 0; i < tankList.size(); i++)
  {
    if (i == 0)
    {
      float rectHeight = maxHeight*tank.score/121/(totalGames-1);
      rect(x+13*i, y+35-rectHeight, 8, rectHeight);
    } else if (i == 1)
    {
      float rectHeight = maxHeight*tank.secondPlace/(totalGames-1);
      rect(x+13*i, y+35-rectHeight, 8, rectHeight);
    } else if (i == 2)
    {
      float rectHeight = maxHeight*tank.thirdPlace/(totalGames-1);
      rect(x+13*i, y+35-rectHeight, 8, rectHeight);
    } else if (i == 3)
    {
      float rectHeight = maxHeight*tank.fourthPlace/(totalGames-1);
      rect(x+13*i, y+35-rectHeight, 8, rectHeight);
    }
  }
  fill(0xFF000000);
}

 public void drawStatsButton()
{
  if (STATS)
  {
    pushMatrix();
    translate(40, 860);
    rotate(statsAngle);
    statsAngle +=0.05f;
    image(statsButton, 0, 0);
    popMatrix();
  } else
  {
    image(statsButton, 40, 860);
  }
}



public class Beam
{
  float angle;
  Line line;
  Tank targetTank;
  Tank firedTank;
  String team = "";
  float w, h;
  PImage img;
  float time;

  Float bezierPoints[];
  Line bezier2;
  AudioPlayer fireSound;
  
  public Beam(float centerX, float centerY, float w2, float h2, float firedAngle, Tank firedTank2)
  {
    w = w2;
    h = h2;
    firedTank = firedTank2;
    angle = firedAngle;
    float radAngle = angle/360*TWO_PI;
    line = new Line(centerX+cos(radAngle)*(w/2), centerY+sin(radAngle)*(w/2), centerX+cos(radAngle)*(1400), centerY+sin(radAngle)*(1400));
    imageMode(CENTER);
    team = firedTank.team;
    img = loadImage("Beam/" + team + " Beam.png");
    fireSound = minim.loadFile("Sounds/Death Ray.mp3");
  }


  public void display(float time2)
  {
    time = time2;
    time = 3.5f*30-time;
    if (time >45)
    {

      noFill();
      if (team == "Blue")
      {
        stroke(27, 30, 247);
    } else if (team == "Green")
      {
        stroke(57, 240, 57);
      } 
       else if (team == "Orange")
      {
        stroke(237,138,5);
      } 
      else
      {
        stroke(204, 0, 0);
      }
      strokeWeight(7);
      if (bezier2 != null)
      {
        bezier2.display2();
      } else
      {
        line.display2();
      }
      if (bezierPoints != null)
      {
        bezier(bezierPoints[0]+OFFSETX, bezierPoints[1]+OFFSETY, bezierPoints[2]+OFFSETX, bezierPoints[3]+OFFSETY, bezierPoints[4]+OFFSETX, bezierPoints[5]+OFFSETY, bezierPoints[6]+OFFSETX, bezierPoints[7]+OFFSETY);
      }
      for (int i = 0; i < 100; i+=7)
      {
        float t = i/100.0f;
        float x, y, tx, ty, rand;
        if (bezierPoints != null)
        {
          x = bezierPoint(bezierPoints[0], bezierPoints[2], bezierPoints[4], bezierPoints[6], t);
          y = bezierPoint(bezierPoints[1], bezierPoints[3], bezierPoints[5], bezierPoints[7], t);

          tx = bezierTangent(bezierPoints[0], bezierPoints[2], bezierPoints[4], bezierPoints[6], t);
          ty = bezierTangent(bezierPoints[1], bezierPoints[3], bezierPoints[5], bezierPoints[7], t);
          rand = (int)random(0, 3);
          if (rand != 0)
          {
            pushMatrix();
            float rad_angle = atan2(ty, tx);
            rad_angle += PI;
            translate(x, y);
            rotate(rad_angle);
            float r = sqrt(OFFSETX*OFFSETX+OFFSETY*OFFSETY);
            float theta = atan(OFFSETY/OFFSETX)-rad_angle;
            translate(r*cos(theta), r*sin(theta));
            image(img, 0, 0);
            popMatrix();
          }
        }
      }
      for (int i = 0; i < 100; i+=2)
      {
        float t = i/100.0f;
        float x, y, tx, ty, rand;
        if (bezier2 != null)
        {
          x = bezier2.lerpX(t);
          y = bezier2.lerpY(t);
          rand = (int)random(0, 3);
          if (rand == 0)
          {
            pushMatrix();
            float rad_angle = bezier2.radAngle();
            translate(x, y);
            rotate(rad_angle);
            float r = sqrt(OFFSETX*OFFSETX+OFFSETY*OFFSETY);
            float theta = atan(OFFSETY/OFFSETX)-rad_angle;
            translate(r*cos(theta), r*sin(theta));
            image(img, 0, 0);
            popMatrix();
          }
        } else
        {
          x = line.lerpX(t);
          y = line.lerpY(t);
          rand = (int)random(0, 3);
          if (rand == 0)
          {
            pushMatrix();
            float rad_angle = line.radAngle();
            translate(x, y);
            rotate(rad_angle);
             float r = sqrt(OFFSETX*OFFSETX+OFFSETY*OFFSETY);
            float theta = atan(OFFSETY/OFFSETX)-rad_angle;
            translate(r*cos(theta), r*sin(theta));
            image(img, 0, 0);
            popMatrix();
          }
        }
      }
    }
    strokeWeight(1);
  }
  
    public void playFireSound()
  {
    fireSound.play();
  }

}

final static float BULLETSPEED = MOVE_SPEED+0.2f;

public class Bullet
{
  
  float x;
  float y;
  float w, h;
  PVector bullet;
  PVector velocity;
  float size;
  int lifeTime;
  boolean isFrag = false;
  float triangleAngle=0;
  AudioPlayer bounceSound;
  AudioPlayer fireSound;
  public Bullet(float firedAngle, float centerX, float centerY, float w, float h, int lifetime2, float size2)
  {
    float radAngle = firedAngle/360*TWO_PI;
   bullet = new PVector(centerX+cos(radAngle)*(w/1.82f), centerY+sin(radAngle)*(w/1.82f)); 
    velocity = new PVector(cos(radAngle)*BULLETSPEED, sin(radAngle)*BULLETSPEED);
    lifeTime = lifetime2*60;
    size = size2;

    fireSound = minim.loadFile("Sounds/Fire.mp3");
    playFireSound();
    bounceSound = minim.loadFile("Sounds/Bounce.mp3");
  }
  
  public Bullet(float firedAngle, float centerX, float centerY, float w, float h, int lifetime2, float size2, int playSound)
  {
    float radAngle = firedAngle/360*TWO_PI;
   bullet = new PVector(centerX+cos(radAngle)*(w/1.8f), centerY+sin(radAngle)*(w/1.8f)); 
    velocity = new PVector(cos(radAngle)*BULLETSPEED, sin(radAngle)*BULLETSPEED);
    lifeTime = lifetime2*60;
    size = size2;


    bounceSound = null;
    bounceSound = minim.loadFile("Sounds/Bounce.mp3");
  }
  
public Bullet(float firedAngle, float centerX, float centerY, float w, float h, int lifetime2, float size2, AudioPlayer fragSound)
  {
    float radAngle = firedAngle/360*TWO_PI;
    bullet = new PVector(centerX+cos(radAngle)*(w/1.8f), centerY+sin(radAngle)*(w/1.8f));
    velocity = new PVector(cos(radAngle)*BULLETSPEED*1.2f, sin(radAngle)*BULLETSPEED*1.2f);
    lifeTime = lifetime2*60;
    size = size2;
    triangleAngle = random(0,2*PI);
    

   //bounceSound = minim.loadFile("Sounds/Frag.mp3", 2048); 
   bounceSound = fragSound;
    isFrag = true;//isFrag2;
  }
  
   public void display()
  {
    bullet.add(velocity);
    
    fill(0);
    if (lifeTime < 30)
    {
      float opacity = lifeTime*255/30.0f;
      if (opacity< .4f*255)
      {
        opacity = .4f*255;
      }
      fill(0,opacity);
      stroke(0,opacity);
    }
    if (!isFrag)
    {
    ellipse(bullet.x+OFFSETX, bullet.y+OFFSETY, size,size);
    }
    else
    {
      pushMatrix();
       translate(bullet.x, bullet.y);
       triangleAngle +=45*PI/180;
       float rotation = triangleAngle;
       rotate(rotation);
        float r = sqrt(OFFSETX*OFFSETX+OFFSETY*OFFSETY);
      float theta = atan(OFFSETY/OFFSETX)-rotation;
      translate(r*cos(theta), r*sin(theta));
triangle(-0.866f*size, -0.5f*size, 0.866f*size, -0.5f*size, 0, size);
 popMatrix();
    }
    //checkCollision();
    lifeTime -= 1;
    x=bullet.x;
    y=bullet.y;
    if (!isFrag)
    {
    if (bounceSound != null && !bounceSound.isPlaying() && bounceSound.position() != 0)
    {
      bounceSound.rewind();
    }
    }
    stroke(0);      
 
  }
  /*
  boolean checkCollision()
  {

    if ((bullet.x > WIDTH-size/2) || (bullet.x < 0+size/2))
    {
      if (!isFrag)
      {
      velocity.x = velocity.x * -1;
      playBounceSound();
      }
      else
      {
        lifeTime = -1;
      }
      return true;
    }
    if (bullet.y > HEIGHT-size/2 || bullet.y < 0-size/2) 
    {
       if (!isFrag)
      {
      velocity.y = velocity.y * -1; 
      playBounceSound();
      }
      else
      {
        lifeTime = -1;
      }
      return true;
    }
    

    return false;
  }
  */
  
   public int getColumn()
  {
    return (int)(bullet.x/CELL_SIZE);
  }
  
   public int getRow()
  {
    return (int)(bullet.y/CELL_SIZE);
  }
  
   public void playFireSound()
  {
    fireSound.play();
  }
  
    public void playBounceSound()
  {
    bounceSound.play();  
  }
}
/*
  Maze Generator.
  Written in Processing 3.
*/

public class Cell{
  public Cell(int x, int y){
    this.x = x;
    this.y = y;
    this.isInMaze = false;;
    this.walls = new Wall[4];
    topLeft = false;
  topRight = false;
  bottomLeft = false;
  bottomRight = false;

  }
  
  public Cell(Cell cell2){
    this.x = cell2.x;
    this.y = cell2.y;
    this.isInMaze = cell2.isInMaze;
    this.walls = cell2.walls;
    topLeft = cell2.topLeft;
  topRight = cell2.topRight;
  bottomLeft = cell2.bottomLeft;
  bottomRight = cell2.bottomRight;
  parent = cell2.parent;
  this.visited= cell2.visited;
  this.hasTank = cell2.hasTank;
  this.target = cell2.target;
  }
  

  public void setIsInMaze(){
    this.isInMaze = true;
  }

  int x;
  int y;
  boolean isInMaze;
  boolean topLeft, topRight, bottomLeft, bottomRight;
  boolean visited = false;
  boolean hasTank = false;
  PowerUp powerUp;
  Cell parent = null;
  
  int target=-1; //0 = top, 1 = bottom, 2 = left, 3 = right
  

  Wall[] walls; // TOP, BOTTOM, LEFT, RIGHT
  
  public float right()
  {
    return y * CELL_SIZE + CELL_SIZE;
  }
  
  public float left()
  {
    return y * CELL_SIZE;
  }
  public float top()
  {
    return x * CELL_SIZE;
  }
  
  public float bottom()
  {
    return x * CELL_SIZE + CELL_SIZE;
  }
  
  public Cell getParent()
  {
    return this.parent;
  }
  
    public void display()
  {
    fill(0xFFFF0000, 25);
    noStroke();
    rect(left(), top(), CELL_SIZE, CELL_SIZE);
  }
  
   public void display2()
  {
    fill(0xFF00FF00, 50);
    noStroke();
    rect(left(), top(), CELL_SIZE, CELL_SIZE);
  }
  
  
}
public class Corner
{
  float x, y;
  float w,h;
  public boolean bottom, top, left, right;
  
  public Corner(float x1, float y1)
  {
    x=x1;
    y=y1;
    w=5;
    h=5;
    bottom = false;
    top = false;
    left = false;
    right = false;
  }
  
  public void display()
  {
    rect(x-w/2+OFFSETY, y-w/2+OFFSETY, 5,5);
  }
  
  public boolean isRightCorner()
  {
    if (top && right && !bottom && !left || !top && !right && bottom && left ||  !top && right && bottom && !left | top && !right && !bottom && left)
    {
      return true;
    }
    return false;
  }
  
  public boolean isStraight()
  {
    if ((top && bottom && !left && !right) || (left && right && !top && !bottom))
    {
      return true;
    }
    return false;
  }
}
public class Explosion
{
  float x,y;
  float w = 120;
  float h = 120;
  float lifeTime = 0;
    ArrayList<Smoke> smokeList = new ArrayList<Smoke>();
  
  AudioPlayer explosionSound;
  public Explosion(float x1, float y1)
  {
    x=x1;
    y=y1;
   explosionSound = minim.loadFile("Sounds/Explosion.mp3");
   playExplosionSound();
  }
  
  public void display()
  {
     if (lifeTime <= 6)
     {
       String filename = "Explosion/frame_" + (int)lifeTime + "_delay-0.1s.png";
       PImage img = loadImage(filename);
       image(img,x+OFFSETX,y+OFFSETY,w,h);
         drawSmoke(x, y, 25);
       
       lifeTime+=0.2f;
     
     }

     updateSmokeList();
  }
  
   public void drawSmoke(float centerX, float centerY, float R)
{
float r = R * sqrt(random(0,1));
float theta = random(0,1) * 2 * PI;
  float x = centerX + r * cos(theta);
float y = centerY + r * sin(theta);
float opacity = random(120,180);
float smokeRadius = random(10,30);

if (smokeList.size()< 20 && frameCount%3==0)
{
smokeList.add(new Smoke(x, y, smokeRadius, opacity, theta));
}

}

 public void updateSmokeList()
{
     for (int i = 0; i < smokeList.size(); i++) //update tank class to same double loop smoke removal system
    {
      Smoke smoke = smokeList.get(i);
      smoke.display();

    }
    for (int i = 0; i < smokeList.size(); i++)
    {
      Smoke smoke = smokeList.get(i);
      if (smoke.opacity < 10)
      {
        smokeList.remove(i);
      }
    }
}


 
  public float generateOffset()
  {
    float r = 6-lifeTime;
    float offset = random(0, r*1.8f);
    return offset;
  }
  
   public void playExplosionSound()
  {
    explosionSound.play();
  }
}


public class Laser
{
  
  float x;
  float y;
  float w, h;
  PVector laserEnd;
  PVector velocity;
  float size;
  int distance;
  ArrayList<Line> lineList = new ArrayList<Line>();
  int range = 500;
  Tank firedTank;
  
  AudioPlayer fireSound;
  public Laser(float centerX, float centerY, float firedAngle, float w, float h, AudioPlayer fireSound2, Tank firedTank2)
  {
    size=5;
    float radAngle = firedAngle/360*TWO_PI;
    laserEnd = new PVector(centerX+cos(radAngle)*(w/2.2f), centerY+sin(radAngle)*(w/2.2f));
    PVector start = new PVector(centerX+cos(radAngle)*(w/2.2f), centerY+sin(radAngle)*(w/2.2f));
    velocity = new PVector(cos(radAngle)*(BULLETSPEED*.5f), sin(radAngle)*BULLETSPEED*.5f);
    distance = 0;
    //laserEnd.add(velocity);
    fireSound = fireSound2;
    firedTank = firedTank2;
    while (distance < range)
    {
        
        while (!laserCollision(this))
        {
          
          lineList.add(new Line(start.x, start.y, laserEnd.x, laserEnd.y));
          if (laserTankCollision(this, false))
          {
            distance = range+100;
            lineList.remove(lineList.size()-1);
            break;
          }
          else
          {
            lineList.remove(lineList.size()-1);
          }
          laserEnd.add(velocity);
          
          
         

          if ((distance + dist(start.x, start.y, laserEnd.x, laserEnd.y) > range))
          {
            break;
          }
         
        }

      lineList.add(new Line(start.x, start.y, laserEnd.x, laserEnd.y));
      distance += dist(start.x, start.y, laserEnd.x, laserEnd.y);
      x=laserEnd.x;
      y=laserEnd.y;
      start.x = x;
      start.y = y;
      if (lineList.size() > 20)
        break;
      
    }
   
    
    
  }
   public void displayFire(String team)
  {
      for (Line line: lineList)
    {
    line.displayLaser(team); 
    }

  }
  
  
   public void fire(String team)
  {
    displayFire(team);
    playFireSound();
    laserTankCollision(this, true);
  }
  
   public void display(String team)
  {
    for (Line line: lineList)
    {
      //requires Dashed Lines from tools->manage toosl->library
      strokeWeight(1.5f); 
      
      if (team == "Red")
      {
        stroke(0xFFFF0000);
      }
      else if (team == "Green")
      {
        stroke(0xFF00FF00);
      }
      else if (team == "Orange")
      {
        stroke(0xFFED8A05);
      }
      else
      {
        stroke(0xFF0000FF);
      }
      
      dash.line(line.x1+OFFSETX, line.y1+OFFSETY, line.x2+OFFSETX, line.y2+OFFSETY);
      stroke(0xFF000000);
  }
  }
  
  
  
   public int getColumn()
  {
    return (int)(laserEnd.x/CELL_SIZE);
  }
  
   public int getRow()
  {
    return (int)(laserEnd.y/CELL_SIZE);
  }
  
  
    public void playFireSound()
  {
    fireSound.play();
  }

}
public class Line
{
  float x1, x2, y1, y2;
  boolean isHorizental = false;
  boolean isVertical = false;
  public Line(float x11, float y11, float x22, float y22)
  {
    x1=x11;
    y1=y11;
    x2=x22;
    y2=y22;
    if (x1 == x2)
    {
        isVertical = true;
    }
    if (y1 == y2)
    {
      isHorizental = true;
    }
  }
  
  public void display()
  {
    stroke(0xFFFF0000);
    strokeWeight(2);
    line(x1+OFFSETX,y1+OFFSETY,x2+OFFSETX,y2+OFFSETY);
    stroke(0xFF000000);
  }
  
  public void display(int color2)
  {
    stroke(color2);
    strokeWeight(2);
    line(x1+OFFSETX,y1+OFFSETY,x2+OFFSETX,y2+OFFSETY);
    stroke(0xFF000000);
  }
  
  public void displayLaser(String team)
  {
    strokeWeight(2); 
       if (team == "Red")
      {
        stroke(0xFFFF0000);
      }
      else if (team == "Green")
      {
        stroke(0xFF00FF00);
      }
      else if (team == "Orange")
      {
        stroke(0xFFED8A05);
      }
      else
      {
        stroke(0xFF0000FF);
      }
    line(x1+OFFSETX,y1+OFFSETY,x2+OFFSETX,y2+OFFSETY);
    stroke(0xFF000000);
  }
  
  public float midX()
  {
    return (x1+x2)/2;
  }
  
  public float midY()
  {
    return (y1+y2)/2;
  }
  
  public void display2()
  {
  line(x1+OFFSETX,y1+OFFSETY,x2+OFFSETX,y2+OFFSETY);
  }
  
  public float lerpY(float t)
  {
    return (1-t)*y1 + t*y2;
  }
  
  public float lerpX(float t)
  {
    return (1-t)*x1 + t*x2;
  }
  
  public float slope()
  {
    return (y2-y1)/(x2-x1);
  }
  
  public float radAngle()
  {
    float rad_angle = atan2((y2-y1), (x2-x1));
     rad_angle += PI;
     return rad_angle;
  }
  
  public boolean equals(Line otherLine)
  {
    if (otherLine.x1 == this.x1 && otherLine.x2 == this.x2 && otherLine.y1 == this.y1 && otherLine.y2 == this.y2)
    {
      return true;
    }
    return false;
  }
}
/*
  Maze Generator.
 Written in Processing 3.
 */

public class Maze {
  public Maze(int rows, int cols) {
    this.rows = rows;
    this.cols = cols;

    this.grid = new Cell[rows][cols];
    wallList = new ArrayList();
    generateCells();
    generateMaze();
    openMaze();
    addCorners();
    
  }

  private void generateMaze() {
    Cell currentCell = grid[PApplet.parseInt(random(rows))][PApplet.parseInt(random(cols))];

    firstCell = currentCell;
    insertCellToMaze(currentCell, null);

    while (!wallList.isEmpty()) {
      Wall currentWall = wallList.get(PApplet.parseInt(random(wallList.size())));

      if (!currentWall.isEdge) {
        if (!(currentWall.c1.isInMaze && currentWall.c2.isInMaze)) {
          currentWall.toOpenWall();

          if (currentWall.c1.isInMaze) {
            insertCellToMaze(currentWall.c2, currentWall);
          } else {
            insertCellToMaze(currentWall.c1, currentWall);
          }
        }
      }
      wallList.remove(currentWall);
    }

    do {
      endCell = grid[PApplet.parseInt(random(rows))][PApplet.parseInt(random(cols))];
    } while (firstCell == endCell);
    //getMazeArray();
  }
  
   public void getMazeArray()
  {
    for (int i = 0; i < rows*2-1; i+=2)
    {
      for (int j = 0; j < cols*2-1; j+=2)
      {
        //0 = top
        //1 = bottom
        //2 = left
        //3 = right
        Wall[] walls = grid[i/2][j/2].walls;
        mazeArray[i][j] = 0;
        if (walls[3].isOpen)
        {
          mazeArray[i][j+1] = 1;       
        }
        else
        {
          mazeArray[i][j+1] = 0; 
        }
        if (walls[1].isOpen)
        {
          mazeArray[i+1][j] = 1;       
        }
        else
        {
          mazeArray[i][j+1] = 0; 
        }

      }
    }
     for (int i = 0; i < rows*2-1; i+=2)
    {
      for (int j = 0; j < cols*2-1; j+=2)
      {
        print(mazeArray[i][j]);
      }
      println("");
    }
  }

  //Inserts the cell to the maze and its walls, but skip one of the wall.
  private void insertCellToMaze(Cell pCell, Wall skipWall) {
    pCell.setIsInMaze();
    for (Wall wall : pCell.walls) {
      if (wall != skipWall) {
        wallList.add(wall);
      }
    }
  }

  //Initializes the grid of cells
  private void generateCells() {
    for (int i = 0; i < rows; ++i) {
      for (int j = 0; j < cols; ++j) {
        grid[i][j] = new Cell(i, j);
      }
    }
    generateWalls(); //Set all the walls of the maze.
  }

  //Initializes the walls of cells
  private void generateWalls() {
    for (int i = 0; i < rows; ++i) {
      for (int j = 0; j < cols; ++j) {

        // FIX TOP WALL
        if (i == 0) {
          grid[i][j].walls[0] = new Wall();
          grid[i][j].walls[0].c1 = grid[i][j];
          grid[i][j].walls[0].setIsEdge();
        } else {
          grid[i][j].walls[0] = grid[i-1][j].walls[1]; //The top wall is the same that the bottom wall above the cell.
          grid[i][j].walls[0].c2 = grid[i][j];
        }

        //FIX BOTTOM WALL
        grid[i][j].walls[1] = new Wall();
        grid[i][j].walls[1].c1 = grid[i][j];
        if (i == rows-1) {
          grid[i][j].walls[1].setIsEdge();
        }

        //FIX LEFT WALL
        if (j == 0) {
          grid[i][j].walls[2] = new Wall();
          grid[i][j].walls[2].c1 = grid[i][j];
          grid[i][j].walls[2].setIsEdge();
        } else {
          grid[i][j].walls[2] = grid[i][j-1].walls[3]; //The left wall is the same that the right wall of the previous cell.
          grid[i][j].walls[2].c2 = grid[i][j];
        }

        //FIX RIGHT WALL
        grid[i][j].walls[3] = new Wall();
        grid[i][j].walls[3].c1 = grid[i][j];
        if (j == cols-1) {
          grid[i][j].walls[3].setIsEdge();
        }
      }
    }
  }

  public void addCorners()
  {
    for (int i = 0; i < rows-1; i++)
    {
      for (int j = 0; j < cols-1; j++)
      {
        //0 = top
        //1 = bottom
        //2 = left
        //3 = right
        Wall[] topLeft = grid[i][j].walls;
        Wall[] topRight = grid[i][j+1].walls;
        Wall[] bottomLeft = grid[i+1][j].walls;
        Wall[] bottomRight = grid[i+1][j+1].walls;
        boolean right, left, top, bottom;
        right = false;
        left = false;
        top = false;
        bottom = false;
        if (!topLeft[1].isOpen || !bottomLeft[0].isOpen)
        {
          left = true;
        }
        if (!topRight[1].isOpen || !bottomRight[0].isOpen)
        {
          right = true;
        }
        if (!topRight[2].isOpen || !topLeft[3].isOpen)
        {
          top = true;
        }
        if (!bottomRight[2].isOpen || !bottomLeft[3].isOpen)
        {
          bottom = true;
        }
        
        boolean addCorner = false;
        if (left && bottom && !top && !right)
        {
          addCorner = true; 
        }
        else if (!left && !bottom && top && right)
        {
          addCorner = true;
        }
        else if (!left && !top && bottom && right)
        {
          addCorner = true;
        }
        else if (left && top && !bottom && !right)
        {
          addCorner = true;
        }
        else if (exactlyOneTrue(top, right, left, bottom))
        {
          addCorner = true;
        }
        if (addCorner)
        {
          Corner newCorner = new Corner(j*CELL_SIZE+CELL_SIZE, i*CELL_SIZE+CELL_SIZE);
          newCorner.left = left;
          newCorner.right = right;
          newCorner.top = top;
          newCorner.bottom = bottom;
          corners.add(newCorner);
        }

      }
    }
  }
  
  private void openMaze()
  {
    for (int i = 1; i < rows-1; ++i) {
      for (int j = 1; j < cols-1; ++j) {
          Cell cell = grid[i][j];
          int delete =(int)random(0, 8);
          if (delete == 0)
          {
            for (Wall wall: cell.walls)
            {
              delete =(int)random(0, 3);
          if (delete != 0)
          {
              wall.toOpenWall();
          }
            }
          }
          
        
      }
    }
  }

  public void viewCorners()
  {
    for (Corner corner : corners)
    {
      corner.display();
    }
  }

  public ArrayList<Cell> getSurroundingCells(int cellRow, int cellCol)
  {

    ArrayList<Cell> cells = new ArrayList<Cell>();
    cells.add(grid[cellRow][cellCol]);
    for (int i = cellRow - 1; i <= cellRow+1; i++)
    {
      for (int j = cellCol -1; j <= cellCol+1; j++)
      {
        if (!(i < 0) && !(i>rows-1) && !(j<0) && !(j>cols-1))
        {
          if (!(i == cellRow && j == cellCol))
          {
          cells.add(grid[i][j]);
          }
        }
      }
    }
    return cells;
  }
  
  public void generatePowerUps()
  {
    int count = countPowerUps();
    if (count <= 10)
    {
    for (int i = 0; i < rows; ++i) {
      for (int j = 0; j < cols; ++j) {
          Cell cell = grid[i][j];
          int random =(int)random(0, 40000);

          if (cell.powerUp == null)
          {
            if (random == 0)
            {
              int powerSelector =(int)random(0,6);
              //powerSelector=3;
              cell.powerUp = new PowerUp(j*CELL_SIZE+35, i*CELL_SIZE+35, powerSelector);
              cell.powerUp.playSpawnSound();
              POWERCOUNT+=1;
            }
          }
          
        
      }
    }
    }
  }
  
  public int countPowerUps()
  {
    int count = 0;
    for (int i = 0; i < rows; ++i) {
      for (int j = 0; j < cols; ++j) {
          Cell cell = grid[i][j];
          if (cell.powerUp != null)
          {
             count++;
          }     
        
      }
    }
    return count;
  }
  
  private boolean exactlyOneTrue(boolean b1, boolean b2, boolean b3, boolean b4)
  {
    if (b1 && !b2 && !b3 && !b4)
    {
      return true;
    }
    if (!b1 && b2 && !b3 && !b4)
    {
      return true;
    }
    if (!b1 && !b2 && b3 && !b4)
    {
      return true;
    }
    if (!b1 && !b2 && !b3 && b4)
    {
      return true;
    }
    return false;
  }
  
    public void clearVisited() {
    for (int i = 0; i < rows; ++i) {
      for (int j = 0; j < cols; ++j) {
        grid[i][j].visited = false;
      }
    }
   }
   
    public void clearParents() {
    for (int i = 0; i < rows; ++i) {
      for (int j = 0; j < cols; ++j) {
        grid[i][j].parent=null;
      }
    }
   }


  int rows;
  int cols;

  Cell firstCell;
  Cell endCell;

  Cell[][] grid;
  ArrayList<Wall> wallList;
  ArrayList <Corner> corners = new ArrayList<Corner>();
  
  int[][] mazeArray = new int[20][32];
}


final static float TIMEBEFORETRACK = 150;

public class Missle
{
  PImage img;
  float centerX, centerY;
  float speed;
  float angle;
  float angleChange = 0;
  float w, h;
  public Queue<Cell> q = new LinkedList<Cell>();
  Maze maze;
  Tank targetTank;
  int lifeTime = 0;
  ParticleSystem smoke;
  PImage smokeImg;
  int targetX=-1;
  int targetY=-1;
  int lastTarget = 2;
  int missleW = 30;
  int missleH = 15;
  AudioPlayer fireSound;
  AudioPlayer trackSound;
  Tank firedTank;
  
  public Missle(float x, float y, float firedAngle, Maze maze2, AudioPlayer fireSound2, AudioPlayer trackSound2, Tank firedTank2)
  {
    firedTank = firedTank2;
    img = loadImage("Missle Shot.png");
    w = (img.width);
    h = (img.height);

    speed = BULLETSPEED*1;//*.8;
    angle = firedAngle;

    float radAngle = angle/360*TWO_PI;
    centerX = x+cos(radAngle)*(w/1);
    centerY = y+sin(radAngle)*(w/1);

    imageMode(CENTER);
    maze = maze2;


    smokeImg = loadImage("Smoke.png");
    smoke = new ParticleSystem(0, new PVector(width/2, height-60), smokeImg);
    fireSound = fireSound2;
    trackSound = trackSound2;
  }


  public void display()
  {
    float rad_angle = angle/360*TWO_PI;
    smoke.origin = new PVector(centerX-cos(rad_angle)*(missleW/1.8f), centerY-sin(rad_angle)*(missleW/1.8f));
    PVector wind;

    wind = new PVector(-0.07f*cos(rad_angle), -0.07f*sin(rad_angle));




    smoke.applyForce(wind);
    smoke.run();
    for (int i = 0; i < 2; i++) {
      smoke.addParticle();
    }

    if (lifeTime > TIMEBEFORETRACK)
    {
      getAngle();
      speed = .8f*BULLETSPEED;
      playTrackSound();
    }
    pushMatrix();

    translate(centerX, centerY);
    rotate(rad_angle);
    float r = sqrt(OFFSETX*OFFSETX+OFFSETY*OFFSETY);
    float theta = atan(OFFSETY/OFFSETX)-rad_angle;
    translate(r*cos(theta), r*sin(theta));
    image(img, 0, 0, w, h);
    popMatrix();
    angle += angleChange;
    rad_angle = angle/360*TWO_PI;

    centerX += speed*cos(rad_angle);
    centerY += speed*sin(rad_angle);
    lifeTime+=1;
  }

  public void getAngle()
  {
    Cell p = getPathBFS(getColumn(), getRow());
        int mouseAngle=0;
    if (p != null)
    {
    targetX = p.x;
    targetY = p.y;

    if (targetTank != null)
    {
      //println(targetTank.team);
      if (targetTank.team.equals("Green"))
      {
        smoke.img = loadImage("Green Smoke.png");
      } else if (targetTank.team.equals("Red"))
      {
        smoke.img = loadImage("Red Smoke.png");
      } else if (targetTank.team.equals("Blue"))
      {
        smoke.img = loadImage("Blue Smoke.png");
      }
      else if (targetTank.team.equals("Orange"))
      {
        smoke.img = loadImage("Orange Smoke.png");
      }
    }
    }

    if (p == null || p.getParent() == null)
    {
      if (targetTank != null)
      {
        mouseAngle = (int)(atan2(centerY - targetTank.centerY, centerX- targetTank.centerX)* 180/ PI);
        if (missleTankCollision())
        {
          targetTank.kill(firedTank);
          explosions.add(new Explosion(targetTank.centerX, targetTank.centerY));
          stopSound();
          lifeTime = 5000;
          
        }
      }
    } else
    {
      while (p.getParent().getParent() != null) {
        if (DEBUG)
        {

          p.display();
        }
        if (p.target == -1)
        {
          if (lastTarget == 2)
          {
            p.target = 3;
            lastTarget = 3;
          } else
          {
            p.target=2;
            lastTarget=2;
          }
        }
        p = p.getParent();
      }

      //println(p.target);
      if (p.target== -1)
      {
        p.target = (int)random(0, 4);
      }


      int px = p.y;
      int py = p.x;

      float yOffset=0;
      float xOffset=0;
      mouseAngle = (int)(atan2(centerY - (py*CELL_SIZE+CELL_SIZE/2), centerX- (px*CELL_SIZE+CELL_SIZE/2))* 180/ PI);

      if (p.target == 0)
      {
        yOffset = CELL_SIZE/3;
        xOffset = CELL_SIZE/3;
        ;
      } else if (p.target == 1)
      {
        yOffset = -CELL_SIZE/3;
        xOffset = -CELL_SIZE/3;
        ;
      } else if (p.target == 2)
      {
        yOffset = -CELL_SIZE/3;
        ;
        xOffset = CELL_SIZE/3;
      } else
      {
        yOffset = CELL_SIZE/3;
        ;
        xOffset = -CELL_SIZE/3;
      }


      mouseAngle = (int)(atan2(centerY - (py*CELL_SIZE+CELL_SIZE/2+yOffset), centerX- (px*CELL_SIZE+CELL_SIZE/2+xOffset))* 180/ PI);
    }
    if (mouseAngle < 0)
    {
      mouseAngle += 360;
    }
    mouseAngle += 180;
    mouseAngle = mouseAngle%360;
    if (angle < 0)
    {
      angle += 360;
    }
    angle = angle %360;



    float a = (mouseAngle - angle);
    float b = (mouseAngle - angle + 360);
    float c = (mouseAngle - angle-360);
    float d;
    if (abs(a) < abs(b) && abs(a) < abs(c))
    {
      d = a;
    } else if (abs(b) < abs(a) && abs(b) < abs(c))
    {
      d=b;
    } else
    {
      d=c;
    }
    if (false)
    {
      println(mouseAngle);
      println(angle);
      println("---");
    }

    if (d < 0)
    {
      angleChange = -ANGLESPEED;
    } else
    {
      angleChange = ANGLESPEED;
    }
  }


  public  Cell getPathBFS(int x, int y)

  {
    q.clear();
    maze.clearVisited();
    maze.clearParents();
    q.add(maze.grid[y][x]);
    while (!q.isEmpty()) {
      Cell p = q.remove();


      boolean top = false;
      boolean bottom = false;
      boolean right = false;
      boolean left = false;

      int px = p.y;
      int py = p.x;
      //px and py are actual x/y place
      //p.x is row (y)
      //p.y is column (x)

      if (maze.grid[py][px].walls[0].isOpen && maze.grid[py-1][px].walls[1].isOpen)
        top = true;
      if (maze.grid[py][px].walls[1].isOpen && maze.grid[py+1][px].walls[0].isOpen)
        bottom = true;
      if (maze.grid[py][px].walls[3].isOpen && maze.grid[py][px+1].walls[2].isOpen)
        right = true;
      if (maze.grid[py][px].walls[2].isOpen && maze.grid[py][px-1].walls[3].isOpen)
        left = true;


      for (Tank tank : tankList) {
        if (tank.alive)
        {
          if (tank.getRow() == py && tank.getColumn() == px)
          {
            return p;
          }
        }
      }

      if (right && isFree(px+1, py)) { //can go right
        maze.grid[py][px].visited = true;
        Cell nextP = maze.grid[py][px+1];
        nextP.parent = p;
        q.add(nextP);
      }
      if (left && isFree(px-1, py)) { //can go left
        maze.grid[py][px].visited = true;
        Cell nextP = maze.grid[py][px-1];

        nextP.parent = p;
        q.add(nextP);
      }
      if (top && isFree(px, py-1)) { //can go up
        maze.grid[py][px].visited = true;
        Cell nextP = maze.grid[py-1][px];
        nextP.parent = p;
        q.add(nextP);
      }
      if (bottom && isFree(px, py+1)) { //can go dpwm
        maze.grid[py][px].visited = true;
        Cell nextP = maze.grid[py+1][px];
        nextP.parent = p;
        q.add(nextP);
      }
    }
    return null;
  }



  public  boolean isFree(int x, int y) {
    if ((x >= 0 && x < WIDTH/CELL_SIZE) && (y >= 0 && y < HEIGHT/CELL_SIZE) && (maze.grid[y][x].visited == false))
    {
      return true;
    }
    return false;
  }



  public ArrayList<Line> getLines()
  {
    ArrayList <Line> lines = new ArrayList<Line>();
    lines.add(getBottomLine());
    //lines.add(getLeftLine()); //prevent tank from running into its own missile
    lines.add(getRightLine());
    lines.add(getTopLine());

    if (DEBUG)
    {
      for (Line line : lines)
      {
        line.display();
      }
    }
    return lines;
  }
  public Line getBottomLine()
  {
    float x1, y1;
    float x2, y2;
    float rad_angle = angle/360*TWO_PI;
    float centerX2 = centerX-1/6*w;
    x1 = centerX2 + w*2/3/2*cos(rad_angle) -h/2*sin(rad_angle);
    y1 = centerY + w*2/3/2*sin(rad_angle) +h/2*cos(rad_angle);
    x2 = centerX2 - w/2*cos(rad_angle) -h/2*sin(rad_angle);
    y2 = centerY - w/2*sin(rad_angle) +h/2*cos(rad_angle);
    if (false)
    {
      ellipse(x1, y1, 4, 4);
      ellipse(x2, y2, 4, 4);
    }
    return new Line(x1, y1, x2, y2);
  }

  public Line getLeftLine()
  {
    float x1, y1;
    float x2, y2;
    float rad_angle = angle/360*TWO_PI;
    float centerX2 = centerX-1/6*w;
    x1 = centerX2 - w/2*cos(rad_angle) -h/2*sin(rad_angle);
    y1 = centerY - w/2*sin(rad_angle) +h/2*cos(rad_angle);
    x2 = centerX2 - w/2*cos(rad_angle) +h/2*sin(rad_angle);
    y2 = centerY - w/2*sin(rad_angle) -h/2*cos(rad_angle);
    if (false)
    {
      ellipse(x1, y1, 4, 4);
      ellipse(x2, y2, 4, 4);
    }
    return new Line(x1, y1, x2, y2);
  }

  public Line getRightLine()
  {
    float x1, y1;
    float x2, y2;
    float rad_angle = angle/360*TWO_PI;
    float centerX2 = centerX-1/6*w;
    x1 = centerX2 + w*2/3/2*cos(rad_angle) -h/2*sin(rad_angle);
    y1 = centerY + w*2/3/2*sin(rad_angle) +h/2*cos(rad_angle);
    x2 = centerX2 + w*2/3/2*cos(rad_angle) +h/2*sin(rad_angle);
    y2 = centerY + w*2/3/2*sin(rad_angle) -h/2*cos(rad_angle);

    if (false)
    {
      ellipse(x1, y1, 4, 4);
      ellipse(x2, y2, 4, 4);
    }
    return new Line(x1, y1, x2, y2);
  }

  public Line getTopLine()
  {
    float x1, y1;
    float x2, y2;
    float rad_angle = angle/360*TWO_PI;
    float centerX2 = centerX-1/6*w;
    x1 = centerX2 - w/2*cos(rad_angle) +h/2*sin(rad_angle);
    y1 = centerY - w/2*sin(rad_angle) -h/2*cos(rad_angle);
    x2 = centerX2 + w*2/3/2*cos(rad_angle) +h/2*sin(rad_angle);
    y2 = centerY + w*2/3/2*sin(rad_angle) -h/2*cos(rad_angle);
    if (false)
    {
      ellipse(x1, y1, 4, 4);
      ellipse(x2, y2, 4, 4);
    }
    return new Line(x1, y1, x2, y2);
  }

   public void setLeft(float left) {
    centerX = left + w/2;
  }

   public float getLeft() {
    float rad_angle = angle/360*TWO_PI;
    float centerX2 = centerX-1/6*w;
    float x1 = centerX2 + w*2/3/2*cos(rad_angle) -h/2*sin(rad_angle);
    float x2 = centerX2 - w/2*cos(rad_angle) -h/2*sin(rad_angle);
    float x3 = centerX2 + w*2/3/2*cos(rad_angle) +h/2*sin(rad_angle);
    float x4 = centerX2 - w/2*cos(rad_angle) +h/2*sin(rad_angle);
    return min(min(x1, x2), min(x3, x4));
  }
   public void setRight(float right) {
    centerX = right - w/2;
  }
   public float getRight() {
    float rad_angle = angle/360*TWO_PI;
    float centerX2 = centerX-1/6*w;
    float x1 = centerX2 + w*2/3/2*cos(rad_angle) -h/2*sin(rad_angle);
    float x2 = centerX2 - w/2*cos(rad_angle) -h/2*sin(rad_angle);
    float x3 = centerX2 + w*2/3/2*cos(rad_angle) +h/2*sin(rad_angle);
    float x4 = centerX2 - w/2*cos(rad_angle) +h/2*sin(rad_angle);
    return max(max(x1, x2), max(x3, x4));
  }
   public void setTop(float top) {
    centerY = top + h/2;
  }
   public float getTop() {
    float rad_angle = angle/360*TWO_PI;
    float y1 = centerY - w/2*sin(rad_angle) +h/2*cos(rad_angle);
    float y2 = centerY - w/2*sin(rad_angle) -h/2*cos(rad_angle);
    float y3 = centerY + w*2/3/2*sin(rad_angle) +h/2*cos(rad_angle);
    float y4 = centerY + w*2/3/2*sin(rad_angle) -h/2*cos(rad_angle);
    return min(min(y1, y2), min(y3, y4));
  }
   public void setBottom(float bottom) {
    centerY = bottom - h/2;
  }
   public float getBottom() {
    float rad_angle = angle/360*TWO_PI;
    float y1 = centerY - w/2*sin(rad_angle) +h/2*cos(rad_angle);
    float y2 = centerY - w/2*sin(rad_angle) -h/2*cos(rad_angle);
    float y3 = centerY + w*2/3/2*sin(rad_angle) +h/2*cos(rad_angle);
    float y4 = centerY + w*2/3/2*sin(rad_angle) -h/2*cos(rad_angle);
    return max(max(y1, y2), max(y3, y4));
  }

   public int getColumn()
  {
    return (int)(centerX/CELL_SIZE);
  }

   public int getRow()
  {
    return (int)(centerY/CELL_SIZE);
  }

   public boolean missleTankCollision()
  {
    for (Line line : getLines())
    {
      if (lineRect(line, targetTank.getTopLine(), targetTank.getBottomLine(), targetTank.getLeftLine(), targetTank.getRightLine()))
        return true;
    }
    return false;
  }

  // LINE/RECTANGLE
   public boolean lineRect(Line wall, Line line1, Line line2, Line line3, Line line4) {

    // check if the line has hit any of the rectangle's sides
    // uses the Line/Line function below
    boolean left =   lineLine(wall, line1);
    boolean right =  lineLine(wall, line2);
    boolean top =    lineLine(wall, line3);
    boolean bottom = lineLine(wall, line4);

    // if ANY of the above are true, the line
    // has hit the rectangle
    if (left || right || top || bottom) {
      return true;
    }
    return false;
  }
  
    public void playFireSound()
  {
    fireSound.play();
  }
  
   public void playTrackSound()
  {
    trackSound.play();
  }
  
    public void stopSound()
  {
    trackSound.mute();
    fireSound.mute();
  }
}
// A simple Particle class, renders the particle as an image

class Particle {
  PVector loc;
  PVector vel;
  PVector acc;
  float lifespan;
  PImage img;

  Particle(PVector l, PImage img_) {
    acc = new PVector(0, 0);
    float vx = randomGaussian()*0.3f;
    float vy = randomGaussian()*0.3f;
    vel = new PVector(vx, vy);
    loc = l.copy();
    lifespan = 70.0f;
    img = img_;
  }

   public void run() {
    update();
    render();
  }

  // Method to apply a force vector to the Particle object
  // Note we are ignoring "mass" here
   public void applyForce(PVector f) {
    acc.add(f);
  }  

  // Method to update position
   public void update() {
    vel.add(acc);
    loc.add(vel);
    lifespan -= 2.5f;
    acc.mult(0); // clear Acceleration
  }

  // Method to display
   public void render() {
    imageMode(CENTER);
    tint(255, lifespan);
    image(img, loc.x+OFFSETX, loc.y+OFFSETY);
    noTint();
    // Drawing a circle instead
    // fill(255,lifespan);
    // noStroke();
    // ellipse(loc.x,loc.y,img.width,img.height);
  }

  // Is the particle still useful?
   public boolean isDead() {
    if (lifespan <= 0.0f) {
      return true;
    } else {
      return false;
    }
  }
}
// A class to describe a group of Particles
// An ArrayList is used to manage the list of Particles 

class ParticleSystem {

  ArrayList<Particle> particles;    // An arraylist for all the particles
  PVector origin;                   // An origin point for where particles are birthed
  PImage img;

  ParticleSystem(int num, PVector v, PImage img_) {
    particles = new ArrayList<Particle>();              // Initialize the arraylist
    origin = v.copy();                                   // Store the origin point
    img = img_;
    for (int i = 0; i < num; i++) {
      particles.add(new Particle(origin, img));         // Add "num" amount of particles to the arraylist
    }
  }

   public void run() {
    for (int i = particles.size()-1; i >= 0; i--) {
      Particle p = particles.get(i);
      p.run();
      if (p.isDead()) {
        particles.remove(i);
      }
    }
  }

  // Method to add a force vector to all particles currently in the system
   public void applyForce(PVector dir) {
    // Enhanced loop!!!
    for (Particle p : particles) {
      p.applyForce(dir);
    }
  }  

   public void addParticle() {
    particles.add(new Particle(origin, img));
  }
}



public class PowerUp
{
  String type = "";
  float x;
  float y;
  PImage img;
  float lifeTime = 0;
  ArrayList<Smoke> smokeList = new ArrayList<Smoke>();
  float radAngle=0;

  AudioPlayer spawnSound;
  AudioPlayer collectSound;
  public PowerUp(float x2, float y2, int typeNum)
  {
    x = x2;
    y = y2;
    if (typeNum == 0)
    {
      type = "Machine Gun";
    } else if (typeNum == 1)
    {
      type = "Shotgun";
    } else if (typeNum == 2)
    {
      type = "Laser";
    } else if (typeNum == 3)
    {
      type = "Missle";
    } else if (typeNum == 4)
    {
      type = "Beam";
    } else if (typeNum == 5)
    {
      type = "Frag Bomb";
    }
    img = loadImage("Power Ups/"+type+".png");
    spawnSound = minim.loadFile("Sounds/Powerup Spawn.mp3");
    collectSound = minim.loadFile("Sounds/Powerup Collect.mp3");
    radAngle = random(-.4f, .4f)*PI/2;
  }

  public void display()
  {
    float size = 1;
    if (6 <= lifeTime && lifeTime <= 8)
    {
      drawSmoke(x, y, 10);
    }
    if (lifeTime < 4)
    {
      size = 0.7f/4*lifeTime+.5f;
    } else if (lifeTime < 6)
    {
      size = -0.2f/2*(lifeTime-4)+1.2f;
    }

    lifeTime+=0.2f;
    updateSmokeList();
    pushMatrix();
    translate(x+OFFSETX, y+OFFSETY);
    rotate(radAngle);
    scale(size);
    image(img, 0, 0);
    popMatrix();
  }

   public void drawSmoke(float centerX, float centerY, float R)
  {
    float r = R * sqrt(random(0, 1));
    float theta = random(0, 1) * 2 * PI;
    float x = centerX + r * cos(theta);
    float y = centerY + r * sin(theta);
    float opacity = random(120, 180);
    float smokeRadius = random(10, 20);

    if (smokeList.size()< 10 && frameCount%2==0)
    {
      smokeList.add(new Smoke(x, y, smokeRadius, opacity, theta));
    }
  }

   public void updateSmokeList()
  {
    for (int i = 0; i < smokeList.size(); i++) //update tank class to same double loop smoke removal system
    {
      Smoke smoke = smokeList.get(i);
      smoke.displaySmoke();
    }
    for (int i = 0; i < smokeList.size(); i++)
    {
      Smoke smoke = smokeList.get(i);
      if (smoke.opacity < 10)
      {
        smokeList.remove(i);
      }
    }
  }

   public void playSpawnSound()
  {
    spawnSound.play();
  }

   public void playCollectSound()
  {
    collectSound.play();
  }
}
public class Smoke
{
  float x, y;
  float r;
  float opacity;
  float theta = -1;
  float speed = 0.3f;
  
   public Smoke(float x1, float y1, float r2, float opacity2)
  {
    x=x1;
    y=y1;
   r = r2;
   opacity = opacity2;
   theta = -1;
  }
  
  public Smoke(float x1, float y1, float r2, float opacity2, float theta2)
  {
    x=x1;
    y=y1;
   r = r2;
   opacity = opacity2;
   theta = theta2;
  }
  
   public Smoke(float x1, float y1, float r2, float opacity2, float theta2, float speed2)
  {
    x=x1;
    y=y1;
   r = r2;
   opacity = opacity2;
   speed = speed2;
   theta = theta2;
  }
  
  
  public void display()
  {
    if (theta == -1)
    {
fill(color(140, opacity));
noStroke();
circle(x+OFFSETX,y+OFFSETY,r);
r+=.5f;
opacity-=3;
    }
    else
    {
      fill(color(50, opacity));
noStroke();
circle(x+OFFSETX,y+OFFSETY,r);
x += speed*cos(theta);
y += speed*sin(theta);
r+=.2f;
opacity-=2.5f;
    }
  }
  
    public void displaySmoke()
  {
   
      fill(color(180, opacity));
noStroke();
circle(x+OFFSETX,y+OFFSETY,r);
x += speed*cos(theta);
y += speed*sin(theta);
r+=.2f;
opacity-=3;
  
  }
  
  

  
  
}

 

public class Tank
{
  PImage img;
  PImage machineImg;
  PImage shotImg;
  PImage missleImg;
  PImage missleFiredImg;
  PImage laserImg;
  PImage beamImg, beamImg1, beamImg2, beamImg3;
  PImage fragBombImg;
  PImage recoilImg;
  PImage fragRecoilImg;
  float centerX, centerY;
  float speed;
  float angle;
  float angleChange;
  float w, h;
  String team;
  boolean alive = true;
  int score = 0;
  float powerTimer = -1;
  float recoilTimer = -1;
  PowerUp power;
  boolean machineFire = false;
  Laser laser;
  Beam beam;
  Missle missle = null;
  Maze maze;
  boolean pause = false;
  boolean onWall;
  Bullet fragBomb = null;
 

  AudioPlayer missileFireSound = minim.loadFile("Sounds/Missle Launch.mp3");
  AudioPlayer trackSound = minim.loadFile("Sounds/Missle Track.mp3");
  AudioPlayer laserFireSound = minim.loadFile("Sounds/Laser.mp3");
    AudioPlayer shotgunFireSound = minim.loadFile("Sounds/Shotgun.mp3");
      AudioPlayer machinegunFireSound = minim.loadFile("Sounds/Machine Gun.mp3");
      AudioPlayer fragBombFireSound = minim.loadFile("Sounds/Frag Bomb Explosion.mp3");
  ArrayList<Bullet> bulletList = new ArrayList<Bullet>();
    ArrayList<Smoke> smokeList = new ArrayList<Smoke>();

  
  int redKills = 0;
  int blueKills = 0;
  int greenKills = 0;
  int orangeKills = 0;
  int suicides = 0;
  int powerUpsCollected = 0;
  int deaths = 0;
  int bulletsFired=0;
  int fumbles = 0;
  int secondPlace = 0;
  int thirdPlace =0;
  int fourthPlace = 0;
  

  public Tank(String filename, float x, float y, float angle2, int score2, String team2, Maze maze2)
  {
    
    img = loadImage(filename);
    w = (img.width);
    h = (img.height);
    centerX = x;
    centerY=y;
    speed = 0;
    angle = angle2;
    imageMode(CENTER);
    score = score2;
    team = team2;
    machineImg = loadImage("Machine Gun/"+team + " Tank.png");
    shotImg = loadImage("Shotgun/"+team + " Tank.png");
    missleImg = loadImage("Missle/"+team + " Tank.png");
    missleFiredImg = loadImage("Missle/" + team + " Tank Fired.png");
    laserImg = loadImage("Laser/" + team + " Tank.png");
    beamImg = loadImage("Beam/" + team + " Tank.png");
    beamImg1 = loadImage("Beam/" + team + " Tank (1).png");
    beamImg2 = loadImage("Beam/" + team + " Tank (2).png");
    beamImg3 = loadImage("Beam/" + team + " Tank (3).png");
    fragBombImg = loadImage("Frag Bomb/" + team + " Tank.png");
    recoilImg = loadImage("Recoil/" + team + " Tank.png");
    fragRecoilImg = loadImage("Frag Bomb/" + team + " Tank Recoil.png");
    maze = maze2;
    onWall = false;
    

    
  }


  public void reset(float x, float  y, float angle2, Maze maze2)
  {
    this.alive = true;
     centerX = x;
    centerY=y;
     speed = 0;
    angle = angle2;
    maze = maze2;
     onWall = false;
     
       powerTimer = -1;
   recoilTimer = -1;
   power = null;
   machineFire = false;
   missle = null;

   pause = false;
 fragBomb = null;
 bulletList.clear();
 smokeList.clear();
    missileFireSound = minim.loadFile("Sounds/Missle Launch.mp3");
   trackSound = minim.loadFile("Sounds/Missle Track.mp3");
   laserFireSound = minim.loadFile("Sounds/Laser.mp3");
     shotgunFireSound = minim.loadFile("Sounds/Shotgun.mp3");
       machinegunFireSound = minim.loadFile("Sounds/Machine Gun.mp3");
       fragBombFireSound = minim.loadFile("Sounds/Frag Bomb Explosion.mp3");
  }

  public void display()
  {
    if (alive)
    {
      if (pause)
      {
        speed = 0;
        angleChange= 0;
      }


      if (machineFire)
      {
        if (powerTimer % 5 == 0)
        {
          Bullet bullet = new Bullet(angle+random(-4, 4), centerX, centerY, w, h, 3, 5, 0);
          bulletList.add(bullet);
        }
        if (powerTimer == -1)
        {
          powerTimer = 3*30;
        } else if (powerTimer == 0)
        {
          power = null;
          powerTimer = -1;
          machineFire = false;
        } else
        {
          powerTimer -=1;
        }
      }
      if (power != null && power.type == "Laser")
      {

        if (powerTimer == -1) //not fired
        {
          if (!onWall)
          {
          laser = new Laser(centerX, centerY, angle, w, h, laserFireSound, this);
          laser.display(team);
          }
        } else if (powerTimer == 0) //fire ended
        {
          power = null;
          powerTimer = -1;
          laser = null;
        } else //firing
        {
          powerTimer -=1;
          laser.displayFire(team);
        }
      }
      if (power != null && power.type == "Beam")
      {

        if (powerTimer == -1) //not fired
        {
        } else if (powerTimer == 0) //fire ended
        {
          power = null;
          powerTimer = -1;
          pause = false;
          beam = null;
        } else //firing
        {
          powerTimer -=1;
          beam.display(powerTimer);
        }
      }
       for (int i = 0; i < smokeList.size(); i++)
    {
      Smoke smoke = smokeList.get(i);
      smoke.display();
    
      if (smoke.opacity < 10)
      {
        smokeList.remove(i);
      }
    }
      
      pushMatrix();
      float rad_angle = angle/360*TWO_PI;
      translate(centerX, centerY);
      rotate(rad_angle);
      float r = sqrt(OFFSETX*OFFSETX+OFFSETY*OFFSETY);
      float theta = atan(OFFSETY/OFFSETX)-rad_angle;
      translate(r*cos(theta), r*sin(theta));
      image(getImage(), 0, 0, w, h);
      popMatrix();


      angle += angleChange;
      rad_angle = angle/360*TWO_PI;

      centerX += speed*cos(rad_angle);
      centerY += speed*sin(rad_angle);
    }
    for (int i = 0; i < bulletList.size(); i++)
    {
      Bullet aBullet = bulletList.get(i);
      if (aBullet.lifeTime <= 0)
      {
        if (aBullet == fragBomb)
        {
          fragBombExplode();
        }
        bulletList.remove(i);
      }
      aBullet.display();
    }

    if (missle != null)
    {
      missle.display();

      if (missle.lifeTime > 700)
      {
        missle.stopSound();
        missle = null;
        power = null;
        
      }
    }
    
    if (!shotgunFireSound.isPlaying() && shotgunFireSound.position() != 0)
    {
      shotgunFireSound.rewind();
    }
    if (!machinegunFireSound.isPlaying() && machinegunFireSound.position() != 0)
    {
      machinegunFireSound.rewind();
    }
     if (!fragBombFireSound.isPlaying() && fragBombFireSound.position() != 0)
    {
      fragBombFireSound.rewind();
    }
   
  }

  public PImage getImage()
  {
    if (power == null)
    {
        if (recoilTimer == -1)
      {
        return img;
      } else
      {
        recoilTimer-=1;
        return recoilImg;
      }

    } else if (power.type == "Machine Gun")
    {
      return machineImg;
    } else if (power.type == "Shotgun")
    {
      return shotImg;
    } else if (power.type == "Missle")
    {
      if (missle == null)
      {
        return missleImg;
      }
    } else if (power.type == "Laser")
    {
      return laserImg;
    }
    else if (power.type == "Frag Bomb")
    {
      if (recoilTimer == -1)
      {
      return fragBombImg;
      }
      recoilTimer -=1;
      return fragRecoilImg;
    }
    if (power != null && power.type == "Beam")
    {

      if (powerTimer == -1) //not fired
      {
        return beamImg;
      } else //firing
      {
        float time = 3.5f*30-powerTimer;
        if (time < 15)
        {
          return beamImg1;
        } else if (time < 30)
        {
          return beamImg2;
        } else
        {
          return beamImg3;
        }
      }
    }
    return missleFiredImg;
  }
  /*
  public void undoMove()
   {
   
   
   
   float rad_angle = angle/360*TWO_PI;
   
   centerX -= speed*cos(rad_angle);
   centerY -= speed*sin(rad_angle);
   }
   */

   public void fire()
  {
    if (alive)
    {
      if (bulletList.size() < 5)
      {
      bulletsFired++;
      }
 
    if (!onWall|| (power != null &&power.type == "Beam"))
    {
      if (power == null )
      {
        if (bulletList.size() < 5 && alive)
        {
          Bullet bullet = new Bullet(angle, centerX, centerY, w, h, 10, 8); //
          bulletList.add(bullet);
            recoilTimer = 5;
            drawGunSmoke();

        }
      } else
      {
        if (power.type == "Machine Gun")
        {

          machineFire = true;
          machinegunFireSound.play();
        } else if (power.type == "Shotgun")
        {
          int numShells = 6;
          for (int i = 0; i < 5; i++)
          {
            Bullet bullet = new Bullet(angle+(-18+36/numShells*i), centerX, centerY, w, h, 3, 6, 0);
            shotgunFireSound.play();
            bulletList.add(bullet);
          }
          power = null;
        } else if (power.type == "Laser")
        {
          //Bullet bullet = new Bullet(angle, centerX, centerY, w, h, 15, 8);
          //bulletList.add(bullet
          laser.fire(team);
          powerTimer = .5f*30;
        } else if (power.type == "Missle")
        {
          if (missle == null)
          {
            missle = new Missle(centerX, centerY, angle, maze, minim.loadFile("Sounds/Missle Launch.mp3"), minim.loadFile("Sounds/Missle Track.mp3"), this);
            missle.playFireSound();
          }
        } else if (power.type == "Beam")
        {
          if (beam == null)
          {
            beam = new Beam (centerX, centerY, w, h, angle, this);
            powerTimer = 3.5f*30;
            pause = true;
            beam.playFireSound();
          }
        }
         else if (power.type == "Frag Bomb")
        {
          if (powerTimer == -1) // not fired yet
          {
          Bullet bullet = new Bullet(angle, centerX, centerY, w, h, 15, 10);
          fragBomb = bullet;
          bulletList.add(bullet);
          recoilTimer = 10;
           drawGunSmoke();
          powerTimer = 1;
          }
          else // fired, so now explode
          {
            fragBombExplode();
            fragBombFireSound.play();
          }
        }
      }
    } else //on wall
    {
      if (power == null)
      {
        if (bulletList.size() < 5 && alive)
        {
          Bullet bullet = new Bullet(angle, centerX, centerY, 0, 0, 10, 8); // spawn bullet inside tank to instantly kill it
          bulletList.add(bullet);
        }
      } else
      {
        if (power.type == "Frag Bomb")
        {
          if (fragBomb != null)
          {
          fragBombExplode();
          }
          else
          {
            Bullet bullet = new Bullet(angle, centerX, centerY, 0, 0, 15, 8);
        bulletList.add(bullet);
          }
        }
        else
        {
        Bullet bullet = new Bullet(angle, centerX, centerY, 0, 0, 15, 8);
        bulletList.add(bullet);
        }
      }
    }
    }
  }


public void fragBombExplode()
{
  int numFrags = 50;
   for (int i = 0; i < numFrags; i++)
          {
            Bullet bullet;
            if (i%2==0)
            {
             bullet = new Bullet(random(0,360), fragBomb.x, fragBomb.y, 0, 0, 5, 3, minim.loadFile("Sounds/Frag.mp3"));
            }
            else
            {
               bullet = new Bullet(random(0,360), fragBomb.x, fragBomb.y, 0, 0, 5, 3, null);
            }
            
            bulletList.add(bullet);
          }
          fragBomb.lifeTime = -1;
            powerTimer = -1;
            power = null;
            fragBomb = null;
            
          
}




  public ArrayList<Line> getLines()
  {
    ArrayList <Line> lines = new ArrayList<Line>();
    lines.add(getBottomLine());
    lines.add(getLeftLine());
    lines.add(getRightLine());
    lines.add(getTopLine());

    if (DEBUG)
    {
      for (Line line : lines)
      {
        line.display();
      }
    }
    return lines;
  }
  public Line getBottomLine()
  {
    float x1, y1;
    float x2, y2;
    float rad_angle = angle/360*TWO_PI;
    float centerX2 = centerX-1/6*w;
    x1 = centerX2 + w*2/3/2*cos(rad_angle) -h/2*sin(rad_angle);
    y1 = centerY + w*2/3/2*sin(rad_angle) +h/2*cos(rad_angle);
    x2 = centerX2 - w/2*cos(rad_angle) -h/2*sin(rad_angle);
    y2 = centerY - w/2*sin(rad_angle) +h/2*cos(rad_angle);
    if (false)
    {
      ellipse(x1, y1, 4, 4);
      ellipse(x2, y2, 4, 4);
    }
    return new Line(x1, y1, x2, y2);
  }

  public Line getLeftLine()
  {
    float x1, y1;
    float x2, y2;
    float rad_angle = angle/360*TWO_PI;
    float centerX2 = centerX-1/6*w;
    x1 = centerX2 - w/2*cos(rad_angle) -h/2*sin(rad_angle);
    y1 = centerY - w/2*sin(rad_angle) +h/2*cos(rad_angle);
    x2 = centerX2 - w/2*cos(rad_angle) +h/2*sin(rad_angle);
    y2 = centerY - w/2*sin(rad_angle) -h/2*cos(rad_angle);
    if (false)
    {
      ellipse(x1, y1, 4, 4);
      ellipse(x2, y2, 4, 4);
    }
    return new Line(x1, y1, x2, y2);
  }

  public Line getRightLine()
  {
    float x1, y1;
    float x2, y2;
    float rad_angle = angle/360*TWO_PI;
    float centerX2 = centerX-1/6*w;
    x1 = centerX2 + w*2/3/2*cos(rad_angle) -h/2*sin(rad_angle);
    y1 = centerY + w*2/3/2*sin(rad_angle) +h/2*cos(rad_angle);
    x2 = centerX2 + w*2/3/2*cos(rad_angle) +h/2*sin(rad_angle);
    y2 = centerY + w*2/3/2*sin(rad_angle) -h/2*cos(rad_angle);

    if (false)
    {
      ellipse(x1, y1, 4, 4);
      ellipse(x2, y2, 4, 4);
    }
    return new Line(x1, y1, x2, y2);
  }

  public Line getBarrel(boolean missle)
  {
    float x1, y1;
    float x2, y2;
    float x3, y3;
    float x4, y4;
    float rad_angle = angle/360*TWO_PI;
    float centerX2 = centerX-1/6*w;
    x1 = centerX2 + w*2/3/2*cos(rad_angle) -h/2*sin(rad_angle);
    y1 = centerY + w*2/3/2*sin(rad_angle) +h/2*cos(rad_angle);
    x2 = centerX2 + w*2/3/2*cos(rad_angle) +h/2*sin(rad_angle);
    y2 = centerY + w*2/3/2*sin(rad_angle) -h/2*cos(rad_angle);

    x3 = (x1+x2)/2;
    y3 = (y1+y2)/2;
    if (!missle)
    {
    x1 = centerX2 + w/1.8f*cos(rad_angle) -h/2*sin(rad_angle);
    y1 = centerY + w/1.8f*sin(rad_angle) +h/2*cos(rad_angle);
    x2 = centerX2 + w/1.8f*cos(rad_angle) +h/2*sin(rad_angle);
    y2 = centerY + w/1.8f*sin(rad_angle) -h/2*cos(rad_angle);

    }
    else
    {
    x1 = centerX2 + w/1*cos(rad_angle) -h/2*sin(rad_angle);
    y1 = centerY + w/1*sin(rad_angle) +h/2*cos(rad_angle);
    x2 = centerX2 + w/1*cos(rad_angle) +h/2*sin(rad_angle);
    y2 = centerY + w/1*sin(rad_angle) -h/2*cos(rad_angle);
    }
  
    x4 = (x1+x2)/2;
    y4 = (y1+y2)/2;
    if (DEBUG)
    {
      ellipse(x3+OFFSETX, y3+OFFSETY, 4, 4);
      ellipse(x4+OFFSETX, y4+OFFSETY, 4, 4);
    }

    return new Line(x3, y3, x4, y4);
  }



  public Line getTopLine()
  {
    float x1, y1;
    float x2, y2;
    float rad_angle = angle/360*TWO_PI;
    float centerX2 = centerX-1/6*w;
    x1 = centerX2 - w/2*cos(rad_angle) +h/2*sin(rad_angle);
    y1 = centerY - w/2*sin(rad_angle) -h/2*cos(rad_angle);
    x2 = centerX2 + w*2/3/2*cos(rad_angle) +h/2*sin(rad_angle);
    y2 = centerY + w*2/3/2*sin(rad_angle) -h/2*cos(rad_angle);
    if (false)
    {
      ellipse(x1, y1, 4, 4);
      ellipse(x2, y2, 4, 4);
    }
    return new Line(x1, y1, x2, y2);
  }

   public void setLeft(float left) {
    centerX = left + w/2;
  }

   public float getLeft() {
    float rad_angle = angle/360*TWO_PI;
    float centerX2 = centerX-1/6*w;
    float x1 = centerX2 + w*2/3/2*cos(rad_angle) -h/2*sin(rad_angle);
    float x2 = centerX2 - w/2*cos(rad_angle) -h/2*sin(rad_angle);
    float x3 = centerX2 + w*2/3/2*cos(rad_angle) +h/2*sin(rad_angle);
    float x4 = centerX2 - w/2*cos(rad_angle) +h/2*sin(rad_angle);
    return min(min(x1, x2), min(x3, x4));
  }
   public void setRight(float right) {
    centerX = right - w/2;
  }
   public float getRight() {
    float rad_angle = angle/360*TWO_PI;
    float centerX2 = centerX-1/6*w;
    float x1 = centerX2 + w*2/3/2*cos(rad_angle) -h/2*sin(rad_angle);
    float x2 = centerX2 - w/2*cos(rad_angle) -h/2*sin(rad_angle);
    float x3 = centerX2 + w*2/3/2*cos(rad_angle) +h/2*sin(rad_angle);
    float x4 = centerX2 - w/2*cos(rad_angle) +h/2*sin(rad_angle);
    return max(max(x1, x2), max(x3, x4));
  }
   public void setTop(float top) {
    centerY = top + h/2;
  }
   public float getTop() {
    float rad_angle = angle/360*TWO_PI;
    float y1 = centerY - w/2*sin(rad_angle) +h/2*cos(rad_angle);
    float y2 = centerY - w/2*sin(rad_angle) -h/2*cos(rad_angle);
    float y3 = centerY + w*2/3/2*sin(rad_angle) +h/2*cos(rad_angle);
    float y4 = centerY + w*2/3/2*sin(rad_angle) -h/2*cos(rad_angle);
    return min(min(y1, y2), min(y3, y4));
  }
   public void setBottom(float bottom) {
    centerY = bottom - h/2;
  }
   public float getBottom() {
    float rad_angle = angle/360*TWO_PI;
    float y1 = centerY - w/2*sin(rad_angle) +h/2*cos(rad_angle);
    float y2 = centerY - w/2*sin(rad_angle) -h/2*cos(rad_angle);
    float y3 = centerY + w*2/3/2*sin(rad_angle) +h/2*cos(rad_angle);
    float y4 = centerY + w*2/3/2*sin(rad_angle) -h/2*cos(rad_angle);
    return max(max(y1, y2), max(y3, y4));
  }

   public int getColumn()
  {
    return (int)(centerX/CELL_SIZE);
  }

   public int getRow()
  {
    return (int)(centerY/CELL_SIZE);
  }
  
  public void kill(Tank killer)
  {
    int tanksAlive = 0;
    for (Tank tank: tankList)
    {
      if (tank.alive)
      {
        tanksAlive++;
      }
    }
    if (tanksAlive == 1)
    {
      this.fumbles++;
    }
    else if (tanksAlive == 2)
    {
      secondPlace++;
    }
     else if (tanksAlive == 3)
    {
      thirdPlace++;
    }
      else if (tanksAlive == 4)
    {
      fourthPlace++;
    }
    
    this.alive = false;
    this.deaths++;
if (this.team == "Red")
    {
     killer.redKills++;
    }
    else if (this.team == "Green")
    {
      killer.greenKills++;
    }
     else if (this.team == "Blue")
    {
      killer.blueKills++;
    }
     else if (this.team == "Orange")
    {
       killer.orangeKills++;
    }
    
    
  }
  
  public int getKills(Tank killer)
  {

    if (killer.team == "Red")
    {
      return redKills;
    }
    else if (killer.team == "Green")
    {
      return greenKills;
    }
     else if (killer.team == "Blue")
    {
      return blueKills;
    }
     else if (killer.team == "Orange")
    {
      return orangeKills;
    }
    return -1;
  }
  
  public float getTotalKills()
  {
    return redKills+greenKills+blueKills+orangeKills-getKills(this);
  }
  
  public String getKD()
  {
    if (this.deaths == 0)
    {
       return String.format("%.2f",getTotalKills());
    }
    return String.format("%.2f",getTotalKills()/this.deaths);
  }
  
    public String getAccuracy()
  {
    if (bulletsFired == 0)
    {
       return String.format("%.1f",0.0f)+ "  ";
    }
    else if (bulletsFired == getTotalKills())
    {
      return "100";
    }
    return String.format("%.1f",getTotalKills()/this.bulletsFired*100).substring(0,2)+ "  ";
  }
  
  public float getMaxPlace()
  {
    return max(score, max(secondPlace, max(thirdPlace, fourthPlace)));
  }
  
   public void drawGunSmoke()
  {
         float x1, y1;
    float x2, y2;
    float x4, y4;
    float rad_angle = angle/360*TWO_PI;
    float centerX2 = centerX-1/6*w;
    x1 = centerX2 + w/1.8f*cos(rad_angle) -h/2*sin(rad_angle);
    y1 = centerY + w/1.8f*sin(rad_angle) +h/2*cos(rad_angle);
    x2 = centerX2 + w/1.8f*cos(rad_angle) +h/2*sin(rad_angle);
    y2 = centerY + w/1.8f*sin(rad_angle) -h/2*cos(rad_angle);
    
  
    x4 = (x1+x2)/2;
    y4 = (y1+y2)/2;
    if (speed == 0)
    {
      smokeList.add(new Smoke(x4, y4, random(2,6), random(90,110),rad_angle, random(.5f,.7f)));
      smokeList.add(new Smoke(x4, y4, random(2,6),  random(90,110),rad_angle+0.25f, random(.5f,.7f)));
      smokeList.add(new Smoke(x4, y4, random(2,6),  random(90,110),rad_angle-0.25f, random(.5f,.7f)));
    }
    else
    {
      smokeList.add(new Smoke(x4, y4, random(2,6), random(90,110),rad_angle, max(0,speed)+random(.5f,.7f)));
      smokeList.add(new Smoke(x4, y4, random(2,6),  random(90,110),rad_angle+0.25f/speed, max(0,speed)+random(.5f,.7f)));
      smokeList.add(new Smoke(x4, y4, random(2,6),  random(90,110),rad_angle-0.25f/speed, max(0,speed)+random(.5f,.7f)));
    }
  }
  

}
/*
  Maze Generator.
  Written in Processing 3.
*/

public class Wall{
  public Wall(){
    this.isEdge = false;
    this.isOpen = false;
  }
  
  public void toOpenWall(){
    this.isOpen = true;
  }

  public void setIsEdge(){
    this.isEdge = true;
  }

  Cell c1;
  Cell c2;

  boolean isEdge; // Walls that only have one cell
  boolean isOpen;
}


  public void settings() { size(1200, 900); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "TankTrouble" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
